package main

import (
	"bytes"
	"fmt"
	docs "github.com/ipfs/http-api-docs"
	"regexp"
	"strings"
)

const Tab = "    "

type CodeBuilder struct {
	buf *bytes.Buffer
}

func NewCodeBuilder() CodeBuilder {
	return CodeBuilder{new(bytes.Buffer)}
}

func (cb CodeBuilder) AddLine(tabs int, s string, args ...interface{}) {
	fmt.Fprintf(cb.buf, strings.Repeat(Tab, tabs)+s+"\n", args...)
}

func (cb CodeBuilder) AddBlankLines(count int) {
	fmt.Fprintf(cb.buf, strings.Repeat("\n", count))
}

func (cb CodeBuilder) String() string {
	return cb.buf.String()
}

func cleanArgName(name string) string {
	name = strings.Replace(name, "-", "_", -1)
	name = strings.Replace(name, " ", "_", -1)
	return name
}

type PythonFormatter struct {
	endpoint *docs.Endpoint
}

func (md *PythonFormatter) GenerateIntro() string {
	return "# IPFS Interface, autogenerated, don't touch!\n\n"
}

func (md *PythonFormatter) GenerateIndex(endps []*docs.Endpoint) string {
	return "class IPFSInterface:\n\t\n"
}

func (md *PythonFormatter) GenerateEndpointBlock(endp *docs.Endpoint) string {
	md.current_endpoint = endp
	version := strings.Split(docs.IPFSVersion(), ".")[0]
	name := strings.TrimPrefix(endp.Name, "/api/v"+version+"/")
	name = strings.Replace(name, "/", "_", -1)

	cb := NewCodeBuilder()
	args := make([]string, len(endp.Arguments)+1)
	for index, arg := range endp.Arguments {
		args[index] = cleanArgName(arg.Name)
	}
	args[len(endp.Arguments)] = "**kwargs"
	sargs := strings.Join(args, ", ")
	cb.AddLine(1, "def %s(%s):", cleanArgName(name), sargs)
	return cb.String()
}

func (md *PythonFormatter) GenerateArgumentsBlock(args []*docs.Argument, opts []*docs.Argument) string {
	cb := NewCodeBuilder()
	cb.AddLine(2, "\"\"\"")
	cb.AddLine(2, md.endpoint.Description)	
	cb.AddBlankLines(1)
	for _, arg := range args {
		cb.AddLine(2, ":param %s: %s (%s)", cleanArgName(arg.Name), arg.Description, arg.Type)
	}
	for _, arg := range opts {
		cb.AddLine(2, ":param %s: %s (%s)", cleanArgName(arg.Name), arg.Description, arg.Type)
	}
	cb.AddLine(2, "\"\"\"")
	cb.AddBlankLines(2)
	cb.AddLine(2, "%s", md.current_endpoint.Name)
	return cb.String()

	// buf := new(bytes.Buffer)
	// fmt.Fprintf(buf, "#### Arguments\n\n")

	// if len(args)+len(opts) == 0 {
	// 	fmt.Fprintf(buf, "This endpoint takes no arguments.\n")
	// }

	// for _, arg := range args {
	// 	fmt.Fprintf(buf, genArgument(arg, true))
	// }
	// for _, opt := range opts {
	// 	fmt.Fprintf(buf, genArgument(opt, false))
	// }

	// fmt.Fprintf(buf, "\n")
	// return buf.String()
}

func genArgument(arg *docs.Argument, aliasToArg bool) string {
	buf := new(bytes.Buffer)
	alias := arg.Name
	//if aliasToArg {
	//alias = "arg"
	//}
	fixDesc, _ := regexp.Compile(" Default: [a-zA-z0-9-_]+ ?\\.")
	fmt.Fprintf(buf, "  - `%s` [%s]: %s", alias, arg.Type, fixDesc.ReplaceAll([]byte(arg.Description), []byte("")))
	if len(arg.Default) > 0 {
		fmt.Fprintf(buf, ` Default: "%s".`, arg.Default)
	}
	if arg.Required {
		fmt.Fprintf(buf, ` Required: **yes**.`)
	} else {
		fmt.Fprintf(buf, ` Required: no.`)
	}
	fmt.Fprintln(buf)
	return buf.String()
}

func (md *PythonFormatter) GenerateBodyBlock(args []*docs.Argument) string {
	return ""
	var bodyArg *docs.Argument
	for _, arg := range args {
		if arg.Type == "file" {
			bodyArg = arg
			break
		}
	}

	if bodyArg != nil {
		buf := new(bytes.Buffer)
		fmt.Fprintf(buf, `
#### Request Body

Argument "%s" is of file type. This endpoint expects a file in the body of the request as 'multipart/form-data'.

`, bodyArg.Name)
		return buf.String()
	}
	return ""
}

func (md *PythonFormatter) GenerateResponseBlock(response string) string {
	return ""
	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, `Response here`)
	return buf.String()
}

func (md *PythonFormatter) GenerateExampleBlock(endp *docs.Endpoint) string {
	return ""
	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, "#### cURL Example\n\n")
	// fmt.Fprintf(buf, "`")
	// fmt.Fprintf(buf, "curl ")

	// // Assemble arguments which are not of type file
	// var queryargs []string
	// hasFileArg := false
	// for _, arg := range endp.Arguments {
	// 	q := "arg="
	// 	if arg.Type != "file" {
	// 		q += "<" + arg.Name + ">"
	// 		queryargs = append(queryargs, q)
	// 	} else {
	// 		hasFileArg = true
	// 	}
	// }

	// // Assemble options
	// for _, opt := range endp.Options {
	// 	q := opt.Name + "="
	// 	//if !opt.Required { // Omit non required options
	// 	//	continue
	// 	//}
	// 	if len(opt.Default) > 0 {
	// 		q += opt.Default
	// 	} else {
	// 		q += "<value>"
	// 	}
	// 	queryargs = append(queryargs, q)
	// }

	// if hasFileArg {
	// 	fmt.Fprintf(buf, "-F file=@myfile ")
	// }

	// fmt.Fprintf(buf, "\"http://localhost:5001%s", endp.Name)
	// if len(queryargs) > 0 {
	// 	fmt.Fprintf(buf, "?%s\"", strings.Join(queryargs, "&"))
	// } else {
	// 	fmt.Fprintf(buf, "\"")
	// }

	// fmt.Fprintf(buf, "`\n\n***\n")
	return buf.String()
}

func main() {
	endpoints := docs.AllEndpoints()
	formatter := new(PythonFormatter)
	fmt.Println(docs.GenerateDocs(endpoints, formatter))
}
