package main

import (
	"bytes"
	"fmt"
	docs "github.com/ipfs/http-api-docs"
	"regexp"
	"strings"
)

const Tab = "    "

type CodeBuilder struct {
	buf *bytes.Buffer
}

func NewCodeBuilder() CodeBuilder {
	return CodeBuilder{new(bytes.Buffer)}
}

func (cb CodeBuilder) AddLine(tabs int, s string, args ...interface{}) {
	lines := fmt.Sprintf(s, args...)
	for _, line := range strings.Split(lines, "\n") {
		fmt.Fprintf(cb.buf, strings.Repeat(Tab, tabs) + line + "\n")
	}
}

func (cb CodeBuilder) AddBlankLines(count int) {
	fmt.Fprintf(cb.buf, strings.Repeat("\n", count))
}

func (cb CodeBuilder) String() string {
	return cb.buf.String()
}

func cleanName(name string) string {
	name = strings.Replace(name, "/", "_", -1)
	name = strings.Replace(name, "-", "_", -1)
	return strings.Replace(name, " ", "_", -1)
}

func trimEndpointPath(endp *docs.Endpoint) string {
	version := strings.Split(docs.IPFSVersion(), ".")[0]
	return strings.TrimPrefix(endp.Name, "/api/v"+version+"/")
}

func hasJSONResponse(endp *docs.Endpoint) bool {
	trimmed := strings.Trim(endp.Response, " \t\n")
	return strings.HasPrefix(trimmed, "{") && strings.HasSuffix(trimmed, "}")
}

func argDefault(arg *docs.Argument) string {
	if arg.Type == "bool" {
		if arg.Default == "" {
			return "False"
		}
		return "True"
	}
	if arg.Type == "string" && arg.Default == "" {
		return "\"\""
	}
	if arg.Type == "int" && arg.Default == "" {
		return "0"
	}
	return arg.Default
}

func argDescription(arg *docs.Argument) string {
	// first, remove the default if it show up in the description so we can
	// have consistency in how it's displayed
	fixDesc, _ := regexp.Compile(" Default: [a-zA-z0-9-_]+ ?\\.")
	desc := fixDesc.ReplaceAll([]byte(arg.Description), []byte(""))

	if arg.Required {
		return fmt.Sprintf("%s (%s)", desc, arg.Type)
	}
	return fmt.Sprintf("%s (%s)  Default: %s", desc, arg.Type, argDefault(arg))
}

type PythonFormatter struct {
	endpoint *docs.Endpoint
}

func (md *PythonFormatter) GenerateIntro() string {
	cb := NewCodeBuilder()
	cb.AddLine(0, "# IPFS Interface, autogenerated, don't touch!")
	cb.AddBlankLines(2)
	return cb.String()
}

func (md *PythonFormatter) GenerateIndex(endps []*docs.Endpoint) string {
	version := docs.IPFSVersion()
	cb := NewCodeBuilder()
	cb.AddLine(0, "class IPFSInterface:")
	cb.AddLine(1, "\"\"\"")
	cb.AddLine(1, "Autogenerated interface to the IPFS HTTP API version %s", version)
	cb.AddLine(1, "\"\"\"")
	cb.AddBlankLines(1)
	cb.AddLine(1, "VERSION = '%s'", version)
	cb.AddBlankLines(1)
	return cb.String()
}

func (md *PythonFormatter) GenerateEndpointBlock(endp *docs.Endpoint) string {
	md.endpoint = endp
	name := cleanName(trimEndpointPath(endp))

	cb := NewCodeBuilder()
	var args []string
	//args := make([]string, len(endp.Arguments)+1)
	for _, arg := range endp.Arguments {
		if arg.Required {
			args = append(args, cleanName(arg.Name))
		}
	}
	args = append(args, "**kwargs")
	//args[len(endp.Arguments)] = "**kwargs"
	sargs := strings.Join(args, ", ")
	if hasJSONResponse(endp) { 
		cb.AddLine(1, "async def %s(self, %s):", name, sargs)
	} else {
		cb.AddLine(1, "def %s(self, %s):", name, sargs)
	}
	return cb.String()
}

func (md *PythonFormatter) GenerateArgumentsBlock(args []*docs.Argument, opts []*docs.Argument) string {
	cb := NewCodeBuilder()
	cb.AddLine(2, "\"\"\"")
	cb.AddLine(2, md.endpoint.Description)	
	cb.AddBlankLines(1)
	for _, arg := range args {
		cb.AddLine(2, ":param %s: %s", cleanName(arg.Name), argDescription(arg))
	}
	for _, arg := range opts {
		cb.AddLine(2, ":param %s: %s", cleanName(arg.Name), argDescription(arg))
	}
	if hasJSONResponse(md.endpoint) {
		cb.AddLine(2, ":returns: A parsed dict result of:")
		cb.AddBlankLines(1)
		cb.AddLine(3, ".. code-block:: python")
		cb.AddBlankLines(1)
		cb.AddLine(4, strings.Trim(md.endpoint.Response, "\n"))
		cb.AddBlankLines(1)
	} else {
		cb.AddLine(2, ":returns: A readable file like object")
	}
	cb.AddLine(2, "\"\"\"")	
	return cb.String()

	// buf := new(bytes.Buffer)
	// fmt.Fprintf(buf, "#### Arguments\n\n")

	// if len(args)+len(opts) == 0 {
	// 	fmt.Fprintf(buf, "This endpoint takes no arguments.\n")
	// }

	// for _, arg := range args {
	// 	fmt.Fprintf(buf, genArgument(arg, true))
	// }
	// for _, opt := range opts {
	// 	fmt.Fprintf(buf, genArgument(opt, false))
	// }

	// fmt.Fprintf(buf, "\n")
	// return buf.String()
}

func genArgument(arg *docs.Argument, aliasToArg bool) string {
	buf := new(bytes.Buffer)
	alias := arg.Name
	//if aliasToArg {
	//alias = "arg"
	//}
	fixDesc, _ := regexp.Compile(" Default: [a-zA-z0-9-_]+ ?\\.")
	fmt.Fprintf(buf, "  - `%s` [%s]: %s", alias, arg.Type, fixDesc.ReplaceAll([]byte(arg.Description), []byte("")))
	if len(arg.Default) > 0 {
		fmt.Fprintf(buf, ` Default: "%s".`, arg.Default)
	}
	if arg.Required {
		fmt.Fprintf(buf, ` Required: **yes**.`)
	} else {
		fmt.Fprintf(buf, ` Required: no.`)
	}
	fmt.Fprintln(buf)
	return buf.String()
}

func (md *PythonFormatter) GenerateBodyBlock(args []*docs.Argument) string {
	cb := NewCodeBuilder()
	cb.AddLine(2, "endpoint = '%s'", trimEndpointPath(md.endpoint))

	var sargs []string
	//sargs := make([]string, len(args)+1)
	for _, arg := range args {
		if arg.Required {
			sargs = append(sargs, cleanName(arg.Name))
		}
	}
	cb.AddLine(2, "args = [%s]", strings.Join(sargs, ", "))
	//sargs[len(args)] = "**kwargs"
	//sargs = append(sargs, "**kwargs")
	//alist := strings.Join(sargs, ", ")
	if hasJSONResponse(md.endpoint) {
		cb.AddLine(2, "return await self.client.get_parsed(endpoint, args, kwargs)")
	} else {
		cb.AddLine(2, "return self.client.get(endpoint, args, kwargs)")
	}
	cb.AddBlankLines(2)
	return cb.String()

	
	var bodyArg *docs.Argument
	for _, arg := range args {
		if arg.Type == "file" {
			bodyArg = arg
			break
		}
	}

	if bodyArg != nil {
		buf := new(bytes.Buffer)
		fmt.Fprintf(buf, `
#### Request Body

Argument "%s" is of file type. This endpoint expects a file in the body of the request as 'multipart/form-data'.

`, bodyArg.Name)
		return buf.String()
	}
	return ""
}

func (md *PythonFormatter) GenerateResponseBlock(response string) string {
	return ""
	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, `Response here`)
	return buf.String()
}

func (md *PythonFormatter) GenerateExampleBlock(endp *docs.Endpoint) string {
	return ""
	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, "#### cURL Example\n\n")
	// fmt.Fprintf(buf, "`")
	// fmt.Fprintf(buf, "curl ")

	// // Assemble arguments which are not of type file
	// var queryargs []string
	// hasFileArg := false
	// for _, arg := range endp.Arguments {
	// 	q := "arg="
	// 	if arg.Type != "file" {
	// 		q += "<" + arg.Name + ">"
	// 		queryargs = append(queryargs, q)
	// 	} else {
	// 		hasFileArg = true
	// 	}
	// }

	// // Assemble options
	// for _, opt := range endp.Options {
	// 	q := opt.Name + "="
	// 	//if !opt.Required { // Omit non required options
	// 	//	continue
	// 	//}
	// 	if len(opt.Default) > 0 {
	// 		q += opt.Default
	// 	} else {
	// 		q += "<value>"
	// 	}
	// 	queryargs = append(queryargs, q)
	// }

	// if hasFileArg {
	// 	fmt.Fprintf(buf, "-F file=@myfile ")
	// }

	// fmt.Fprintf(buf, "\"http://localhost:5001%s", endp.Name)
	// if len(queryargs) > 0 {
	// 	fmt.Fprintf(buf, "?%s\"", strings.Join(queryargs, "&"))
	// } else {
	// 	fmt.Fprintf(buf, "\"")
	// }

	// fmt.Fprintf(buf, "`\n\n***\n")
	return buf.String()
}

func main() {
	endpoints := docs.AllEndpoints()
	formatter := new(PythonFormatter)
	fmt.Println(docs.GenerateDocs(endpoints, formatter))
}
