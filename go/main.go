package main

import (
	"bytes"
	"fmt"
	docs "github.com/ipfs/http-api-docs"
	"regexp"
	"strings"
)

const Tab = "    "

type CodeBuilder struct {
	buf *bytes.Buffer
}

func NewCodeBuilder() CodeBuilder {
	return CodeBuilder{new(bytes.Buffer)}
}

func (cb CodeBuilder) AddLine(tabs int, s string, args ...interface{}) {
	lines := fmt.Sprintf(s, args...)
	for _, line := range strings.Split(lines, "\n") {
		fmt.Fprintf(cb.buf, strings.Repeat(Tab, tabs)+line+"\n")
	}
}

func (cb CodeBuilder) AddDocstringLine(tabs int, s string, args ...interface{}) {
	lines := fmt.Sprintf(s, args...)
	for index, line := range strings.Split(lines, "\n") {
		if index == 1 {
			tabs = tabs + 1
		}
		if len(strings.Trim(line, "\n\t")) > 0 {
			fmt.Fprintf(cb.buf, strings.Repeat(Tab, tabs)+line+"\n")
		}
	}
}

func (cb CodeBuilder) AddBlankLines(count int) {
	fmt.Fprintf(cb.buf, strings.Repeat("\n", count))
}

func (cb CodeBuilder) String() string {
	return cb.buf.String()
}

func cleanName(name string) string {
	name = strings.Replace(name, "/", "_", -1)
	name = strings.Replace(name, "-", "_", -1)
	name = strings.Replace(name, " ", "_", -1)
	name = strings.Replace(name, "hash", "hashname", -1)
	return strings.ToLower(name)
}

func trimEndpointPath(endp *docs.Endpoint) string {
	version := strings.Split(docs.IPFSVersion(), ".")[0]
	return strings.TrimPrefix(endp.Name, "/api/v"+version+"/")
}

func hasJSONResponse(endp *docs.Endpoint) bool {
	trimmed := strings.Trim(endp.Response, " \t\n")
	return strings.HasPrefix(trimmed, "{") && strings.HasSuffix(trimmed, "}")
}

func argDefault(arg *docs.Argument) string {
	if arg.Type == "bool" {
		if arg.Default == "" || arg.Default == "false" {
			return "False"
		}
		return "True"
	}
	if arg.Type == "string" && arg.Default == "" {
		return "\"\""
	}
	if arg.Type == "int" && arg.Default == "" {
		return "0"
	}
	if arg.Type == "uint" && arg.Default == "" {
		return "0"
	}	
	return arg.Default
}

func argDescription(arg *docs.Argument) string {
	// first, remove the default if it show up in the description so we can
	// have consistency in how it's displayed
	fixDesc, _ := regexp.Compile(" Default: [a-zA-z0-9-_]+ ?\\.")
	desc := fixDesc.ReplaceAll([]byte(arg.Description), []byte(""))
	argtype := arg.Type
	if arg.Type == "file" && arg.Default == "" {
		argtype = "string"
	}
	if arg.Required {
		return fmt.Sprintf("%s (%s)", desc, argtype)
	}
	return fmt.Sprintf("%s (%s)  Default: %s", desc, arg.Type, argDefault(arg))
}

type PythonFormatter struct {
	endpoint *docs.Endpoint
}

func (md *PythonFormatter) GenerateIntro() string {
	cb := NewCodeBuilder()
	cb.AddLine(0, "# IPFS Interface, autogenerated, don't touch!")
	cb.AddBlankLines(2)
	return cb.String()
}

func (md *PythonFormatter) GenerateIndex(endps []*docs.Endpoint) string {
	version := docs.IPFSVersion()
	cb := NewCodeBuilder()
	disable := "too-many-public-methods,line-too-long,too-many-lines"
	cb.AddLine(0, "# pylint: disable=%s", disable)
	cb.AddLine(0, "class IPFSInterface:")
	cb.AddLine(1, "\"\"\"")
	cb.AddLine(1, "Autogenerated interface to the IPFS HTTP API version %s", version)
	cb.AddLine(1, "\"\"\"")
	cb.AddBlankLines(1)
	cb.AddLine(1, "VERSION = '%s'", version)
	cb.AddBlankLines(1)
	cb.AddLine(1, "def __init__(self, client):")
	cb.AddLine(2, "self.client = client")
	return cb.String()
}

func (md *PythonFormatter) GenerateEndpointBlock(endp *docs.Endpoint) string {
	md.endpoint = endp
	name := cleanName(trimEndpointPath(endp))

	cb := NewCodeBuilder()
	cb.AddBlankLines(2)
	var args []string
	for _, arg := range endp.Arguments {
		if arg.Required {
			args = append(args, cleanName(arg.Name))
		}
	}
	args = append(args, "**kwargs")
	sargs := strings.Join(args, ", ")
	if hasJSONResponse(endp) {
		cb.AddLine(1, "async def %s(self, %s):", name, sargs)
	} else {
		cb.AddLine(1, "def %s(self, %s):", name, sargs)
	}
	return cb.String()
}

func (md *PythonFormatter) GenerateArgumentsBlock(args []*docs.Argument, opts []*docs.Argument) string {
	cb := NewCodeBuilder()
	cb.AddLine(2, "\"\"\"")
	if len(md.endpoint.Description) > 0 {
		cb.AddLine(2, md.endpoint.Description)
		cb.AddBlankLines(1)
	}
	for _, arg := range args {
		cb.AddDocstringLine(2, ":param %s: %s", cleanName(arg.Name), argDescription(arg))
	}
	for _, arg := range opts {
		cb.AddDocstringLine(2, ":param %s: %s", cleanName(arg.Name), argDescription(arg))
	}
	if hasJSONResponse(md.endpoint) {
		cb.AddLine(2, ":returns: A parsed dict result of:")
		cb.AddBlankLines(1)
		cb.AddLine(3, ".. code-block:: python")
		cb.AddBlankLines(1)
		cb.AddLine(4, strings.Trim(md.endpoint.Response, "\n"))
		cb.AddBlankLines(1)
	} else {
		cb.AddLine(2, ":returns: A aiohttp.ClientResponse object that can be read like a file.")
	}
	cb.AddLine(2, "\"\"\"")
	return cb.String()
}

func (md *PythonFormatter) GenerateBodyBlock(args []*docs.Argument) string {
	cb := NewCodeBuilder()
	cb.AddLine(2, "endpoint = '%s'", trimEndpointPath(md.endpoint))

	var sargs []string
	for _, arg := range args {
		if arg.Required {
			nametype := fmt.Sprintf("(%s, '%s')", cleanName(arg.Name), arg.Type)
			sargs = append(sargs, nametype)
		}
	}
	cb.AddLine(2, "args = [%s]", strings.Join(sargs, ", "))
	if hasJSONResponse(md.endpoint) {
		cb.AddLine(2, "return await self.client.get_parsed(endpoint, args, kwargs)")
	} else {
		cb.AddLine(2, "return self.client.get(endpoint, args, kwargs)")
	}
	return strings.Trim(cb.String(), "\n")
}

func (md *PythonFormatter) GenerateResponseBlock(response string) string {
	return ""
}

func (md *PythonFormatter) GenerateExampleBlock(endp *docs.Endpoint) string {
	return ""
}

func main() {
	endpoints := docs.AllEndpoints()
	formatter := new(PythonFormatter)
	fmt.Println(docs.GenerateDocs(endpoints, formatter))
}
