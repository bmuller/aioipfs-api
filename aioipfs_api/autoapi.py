# IPFS Interface, autogenerated, don't touch!


# pylint: disable=too-many-public-methods,line-too-long,too-many-lines
class IPFSInterface:
    """
    Autogenerated interface to the IPFS HTTP API version 0.4.15
    """

    VERSION = '0.4.15'

    def __init__(self, client):
        self.client = client


    async def add(self, path, **kwargs):
        """
        Add a file or directory to ipfs.

        :param path: The path to a file to be added to ipfs. (string)
        :param recursive: Add directory paths recursively. (bool)  Default: False
        :param quiet: Write minimal output. (bool)  Default: False
        :param quieter: Write only final hash. (bool)  Default: False
        :param silent: Write no output. (bool)  Default: False
        :param progress: Stream progress data. (bool)  Default: False
        :param trickle: Use trickle-dag format for dag generation. (bool)  Default: False
        :param only_hashname: Only chunk and hash - do not write to disk. (bool)  Default: False
        :param wrap_with_directory: Wrap files with a directory object. (bool)  Default: False
        :param hidden: Include files that are hidden. Only takes effect on recursive add. (bool)  Default: False
        :param chunker: Chunking algorithm, size-[bytes] or rabin-[min]-[avg]-[max]. (string)  Default: size-262144
        :param pin: Pin this object when adding. (bool)  Default: True
        :param raw_leaves: Use raw blocks for leaf nodes. (experimental). (bool)  Default: False
        :param nocopy: Add the file using filestore. Implies raw-leaves. (experimental). (bool)  Default: False
        :param fscache: Check the filestore for pre-existing blocks. (experimental). (bool)  Default: False
        :param cid_version: CID version. Defaults to 0 unless an option that depends on CIDv1 is passed. (experimental). (int)  Default: 0
        :param hashname: Hash function to use. Implies CIDv1 if not sha2-256. (experimental). (string)  Default: sha2-256
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Name": "<string>"
                    "Hash": "<string>"
                    "Bytes": "<int64>"
                    "Size": "<string>"
                }

        """
        endpoint = 'add'
        args = [(path, 'file')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def bitswap_ledger(self, peer, **kwargs):
        """
        Show the current ledger for a peer.

        :param peer: The PeerID (B58) of the ledger to inspect. (string)
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Peer": "<string>"
                    "Value": "<float64>"
                    "Sent": "<uint64>"
                    "Recv": "<uint64>"
                    "Exchanged": "<uint64>"
                }

        """
        endpoint = 'bitswap/ledger'
        args = [(peer, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    def bitswap_reprovide(self, **kwargs):
        """
        Trigger reprovider.

        :returns: A file like object that can be read.
        """
        endpoint = 'bitswap/reprovide'
        args = []
        return self.client.get(endpoint, args, kwargs)

    async def bitswap_stat(self, **kwargs):
        """
        Show some diagnostic information on the bitswap agent.

        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "ProvideBufLen": "<int>"
                    "Wantlist": [
                        "<string>"
                    ]
                    "Peers": [
                        "<string>"
                    ]
                    "BlocksReceived": "<uint64>"
                    "DataReceived": "<uint64>"
                    "BlocksSent": "<uint64>"
                    "DataSent": "<uint64>"
                    "DupBlksReceived": "<uint64>"
                    "DupDataReceived": "<uint64>"
                }

        """
        endpoint = 'bitswap/stat'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    def bitswap_unwant(self, key, **kwargs):
        """
        Remove a given block from your wantlist.

        :param key: Key(s) to remove from your wantlist. (string)
        :returns: A file like object that can be read.
        """
        endpoint = 'bitswap/unwant'
        args = [(key, 'string')]
        return self.client.get(endpoint, args, kwargs)

    async def bitswap_wantlist(self, **kwargs):
        """
        Show blocks currently on the wantlist.

        :param peer: Specify which peer to show wantlist for. (string)  Default: ""
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Keys": [
                        "<string>"
                    ]
                }

        """
        endpoint = 'bitswap/wantlist'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    def block_get(self, key, **kwargs):
        """
        Get a raw IPFS block.

        :param key: The base58 multihash of an existing block to get. (string)
        :returns: A file like object that can be read.
        """
        endpoint = 'block/get'
        args = [(key, 'string')]
        return self.client.get(endpoint, args, kwargs)

    async def block_put(self, data, **kwargs):
        """
        Store input as an IPFS block.

        :param data: The data to be stored as an IPFS block. (string)
        :param format: cid format for blocks to be created with. (string)  Default: ""
        :param mhtype: multihash hash function. (string)  Default: sha2-256
        :param mhlen: multihash hash length. (int)  Default: -1
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Key": "<string>"
                    "Size": "<int>"
                }

        """
        endpoint = 'block/put'
        args = [(data, 'file')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def block_rm(self, hashname, **kwargs):
        """
        Remove IPFS block(s).

        :param hashname: Bash58 encoded multihash of block(s) to remove. (string)
        :param force: Ignore nonexistent blocks. (bool)  Default: False
        :param quiet: Write minimal output. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Hash": "<string>"
                    "Error": "<string>"
                }

        """
        endpoint = 'block/rm'
        args = [(hashname, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def block_stat(self, key, **kwargs):
        """
        Print information of a raw IPFS block.

        :param key: The base58 multihash of an existing block to stat. (string)
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Key": "<string>"
                    "Size": "<int>"
                }

        """
        endpoint = 'block/stat'
        args = [(key, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def bootstrap_add_default(self, **kwargs):
        """
        Add default peers to the bootstrap list.

        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Peers": [
                        "<string>"
                    ]
                }

        """
        endpoint = 'bootstrap/add/default'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def bootstrap_list(self, **kwargs):
        """
        Show peers in the bootstrap list.

        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Peers": [
                        "<string>"
                    ]
                }

        """
        endpoint = 'bootstrap/list'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def bootstrap_rm_all(self, **kwargs):
        """
        Remove all peers from the bootstrap list.

        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Peers": [
                        "<string>"
                    ]
                }

        """
        endpoint = 'bootstrap/rm/all'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    def cat(self, ipfs_path, **kwargs):
        """
        Show IPFS object data.

        :param ipfs_path: The path to the IPFS object(s) to be outputted. (string)
        :param offset: Byte offset to begin reading from. (int)  Default: 0
        :param length: Maximum number of bytes to read. (int)  Default: 0
        :returns: A file like object that can be read.
        """
        endpoint = 'cat'
        args = [(ipfs_path, 'string')]
        return self.client.get(endpoint, args, kwargs)

    async def commands(self, **kwargs):
        """
        List all available commands.

        :param flags: Show command flags. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Name": "<string>"
                    "Subcommands": [
                        {
                            "Name": "<string>"
                            "Subcommands": [
                                {
                                    "Name": "<string>"
                                    "Subcommands": [
                                        ...
                                    ]
                                    "Options": [
                                        ...
                                    ]
                                    "showOpts": "<bool>"
                                }
                            ]
                            "Options": [
                                {
                                    "Names": [
                                        ...
                                    ]
                                }
                            ]
                            "showOpts": "<bool>"
                        }
                    ]
                    "Options": [
                        {
                            "Names": [
                                "<string>"
                            ]
                        }
                    ]
                    "showOpts": "<bool>"
                }

        """
        endpoint = 'commands'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    def config_edit(self, **kwargs):
        """
        Open the config file for editing in $EDITOR.

        :returns: A file like object that can be read.
        """
        endpoint = 'config/edit'
        args = []
        return self.client.get(endpoint, args, kwargs)

    def config_profile_apply(self, profile, **kwargs):
        """
        Apply profile to config.

        :param profile: The profile to apply to the config. (string)
        :returns: A file like object that can be read.
        """
        endpoint = 'config/profile/apply'
        args = [(profile, 'string')]
        return self.client.get(endpoint, args, kwargs)

    def config_replace(self, file, **kwargs):
        """
        Replace the config with <file>.

        :param file: The file to use as the new config. (string)
        :returns: A file like object that can be read.
        """
        endpoint = 'config/replace'
        args = [(file, 'file')]
        return self.client.get(endpoint, args, kwargs)

    def config_show(self, **kwargs):
        """
        Output config file contents.

        :returns: A file like object that can be read.
        """
        endpoint = 'config/show'
        args = []
        return self.client.get(endpoint, args, kwargs)

    def dag_get(self, ref, **kwargs):
        """
        Get a dag node from ipfs.

        :param ref: The object to get (string)
        :returns: A file like object that can be read.
        """
        endpoint = 'dag/get'
        args = [(ref, 'string')]
        return self.client.get(endpoint, args, kwargs)

    async def dag_put(self, object_data, **kwargs):
        """
        Add a dag node to ipfs.

        :param object_data: The object to put (string)
        :param format: Format that the object will be added as. (string)  Default: cbor
        :param input_enc: Format that the input object will be. (string)  Default: json
        :param pin: Pin this object when adding. (bool)  Default: False
        :param hashname: Hash function to use. Default: . (string)  Default: ""
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Cid": "<string>"
                }

        """
        endpoint = 'dag/put'
        args = [(object_data, 'file')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def dag_resolve(self, ref, **kwargs):
        """
        Resolve ipld block

        :param ref: The path to resolve (string)
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Cid": "<string>"
                    "RemPath": "<string>"
                }

        """
        endpoint = 'dag/resolve'
        args = [(ref, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def dht_findpeer(self, peerid, **kwargs):
        """
        Query the DHT for all of the multiaddresses associated with a Peer ID.

        :param peerid: The ID of the peer to search for. (string)
        :param verbose: Print extra information. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "ID": "<string>"
                    "Type": "<int>"
                    "Responses": [
                        {
                            "ID": "<string>"
                            "Addrs": [
                                "<object>"
                            ]
                        }
                    ]
                    "Extra": "<string>"
                }

        """
        endpoint = 'dht/findpeer'
        args = [(peerid, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def dht_findprovs(self, key, **kwargs):
        """
        Find peers in the DHT that can provide a specific value, given a key.

        :param key: The key to find providers for. (string)
        :param verbose: Print extra information. (bool)  Default: False
        :param num_providers: The number of providers to find. (int)  Default: 20
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "ID": "<string>"
                    "Type": "<int>"
                    "Responses": [
                        {
                            "ID": "<string>"
                            "Addrs": [
                                "<object>"
                            ]
                        }
                    ]
                    "Extra": "<string>"
                }

        """
        endpoint = 'dht/findprovs'
        args = [(key, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def dht_get(self, key, **kwargs):
        """
        Given a key, query the DHT for its best value.

        :param key: The key to find a value for. (string)
        :param verbose: Print extra information. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "ID": "<string>"
                    "Type": "<int>"
                    "Responses": [
                        {
                            "ID": "<string>"
                            "Addrs": [
                                "<object>"
                            ]
                        }
                    ]
                    "Extra": "<string>"
                }

        """
        endpoint = 'dht/get'
        args = [(key, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def dht_provide(self, key, **kwargs):
        """
        Announce to the network that you are providing given values.

        :param key: The key[s] to send provide records for. (string)
        :param verbose: Print extra information. (bool)  Default: False
        :param recursive: Recursively provide entire graph. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "ID": "<string>"
                    "Type": "<int>"
                    "Responses": [
                        {
                            "ID": "<string>"
                            "Addrs": [
                                "<object>"
                            ]
                        }
                    ]
                    "Extra": "<string>"
                }

        """
        endpoint = 'dht/provide'
        args = [(key, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def dht_put(self, key, value, **kwargs):
        """
        Write a key/value pair to the DHT.

        :param key: The key to store the value at. (string)
        :param value: The value to store. (string)
        :param verbose: Print extra information. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "ID": "<string>"
                    "Type": "<int>"
                    "Responses": [
                        {
                            "ID": "<string>"
                            "Addrs": [
                                "<object>"
                            ]
                        }
                    ]
                    "Extra": "<string>"
                }

        """
        endpoint = 'dht/put'
        args = [(key, 'string'), (value, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def dht_query(self, peerid, **kwargs):
        """
        Find the closest Peer IDs to a given Peer ID by querying the DHT.

        :param peerid: The peerID to run the query against. (string)
        :param verbose: Print extra information. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "ID": "<string>"
                    "Type": "<int>"
                    "Responses": [
                        {
                            "ID": "<string>"
                            "Addrs": [
                                "<object>"
                            ]
                        }
                    ]
                    "Extra": "<string>"
                }

        """
        endpoint = 'dht/query'
        args = [(peerid, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    def diag_cmds_clear(self, **kwargs):
        """
        Clear inactive requests from the log.

        :returns: A file like object that can be read.
        """
        endpoint = 'diag/cmds/clear'
        args = []
        return self.client.get(endpoint, args, kwargs)

    def diag_cmds_set_time(self, time, **kwargs):
        """
        Set how long to keep inactive requests in the log.

        :param time: Time to keep inactive requests in log. (string)
        :returns: A file like object that can be read.
        """
        endpoint = 'diag/cmds/set-time'
        args = [(time, 'string')]
        return self.client.get(endpoint, args, kwargs)

    def diag_sys(self, **kwargs):
        """
        Print system diagnostic information.

        :returns: A file like object that can be read.
        """
        endpoint = 'diag/sys'
        args = []
        return self.client.get(endpoint, args, kwargs)

    async def dns(self, domain_name, **kwargs):
        """
        Resolve DNS links.

        :param domain_name: The domain-name name to resolve. (string)
        :param recursive: Resolve until the result is not a DNS link. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Path": "<string>"
                }

        """
        endpoint = 'dns'
        args = [(domain_name, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def file_ls(self, ipfs_path, **kwargs):
        """
        List directory contents for Unix filesystem objects.

        :param ipfs_path: The path to the IPFS object(s) to list links from. (string)
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Arguments": {
                        "<string>": "<string>"
                    }
                    "Objects": {
                        "<string>": {
                            "Hash": "<string>"
                            "Size": "<uint64>"
                            "Type": "<string>"
                            "Links": [
                                {
                                    "Name": "<string>"
                                    "Hash": "<string>"
                                    "Size": "<uint64>"
                                    "Type": "<string>"
                                }
                            ]
                        }
                    }
                }

        """
        endpoint = 'file/ls'
        args = [(ipfs_path, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    def files_chcid(self, **kwargs):
        """
        Change the cid version or hash function of the root node of a given path.

        :param path: Path to change. Default: '/'. (string)  Default: ""
        :param cid_version: Cid version to use. (experimental). (int)  Default: 0
        :param hashname: Hash function to use. Will set Cid version to 1 if used. (experimental). (string)  Default: ""
        :returns: A file like object that can be read.
        """
        endpoint = 'files/chcid'
        args = []
        return self.client.get(endpoint, args, kwargs)

    def files_cp(self, source, dest, **kwargs):
        """
        Copy files into mfs.

        :param source: Source object to copy. (string)
        :param dest: Destination to copy object to. (string)
        :returns: A file like object that can be read.
        """
        endpoint = 'files/cp'
        args = [(source, 'string'), (dest, 'string')]
        return self.client.get(endpoint, args, kwargs)

    def files_flush(self, **kwargs):
        """
        Flush a given path's data to disk.

        :param path: Path to flush. Default: '/'. (string)  Default: ""
        :returns: A file like object that can be read.
        """
        endpoint = 'files/flush'
        args = []
        return self.client.get(endpoint, args, kwargs)

    async def files_ls(self, **kwargs):
        """
        List directories in the local mutable namespace.

        :param path: Path to show listing for. Defaults to '/'. (string)  Default: ""
        :param l: Use long listing format. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Entries": [
                        {
                            "Name": "<string>"
                            "Type": "<int>"
                            "Size": "<int64>"
                            "Hash": "<string>"
                        }
                    ]
                }

        """
        endpoint = 'files/ls'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    def files_mkdir(self, path, **kwargs):
        """
        Make directories.

        :param path: Path to dir to make. (string)
        :param parents: No error if existing, make parent directories as needed. (bool)  Default: False
        :param cid_version: Cid version to use. (experimental). (int)  Default: 0
        :param hashname: Hash function to use. Will set Cid version to 1 if used. (experimental). (string)  Default: ""
        :returns: A file like object that can be read.
        """
        endpoint = 'files/mkdir'
        args = [(path, 'string')]
        return self.client.get(endpoint, args, kwargs)

    def files_mv(self, source, dest, **kwargs):
        """
        Move files.

        :param source: Source file to move. (string)
        :param dest: Destination path for file to be moved to. (string)
        :returns: A file like object that can be read.
        """
        endpoint = 'files/mv'
        args = [(source, 'string'), (dest, 'string')]
        return self.client.get(endpoint, args, kwargs)

    def files_read(self, path, **kwargs):
        """
        Read a file in a given mfs.

        :param path: Path to file to be read. (string)
        :param offset: Byte offset to begin reading from. (int)  Default: 0
        :param count: Maximum number of bytes to read. (int)  Default: 0
        :returns: A file like object that can be read.
        """
        endpoint = 'files/read'
        args = [(path, 'string')]
        return self.client.get(endpoint, args, kwargs)

    def files_rm(self, path, **kwargs):
        """
        Remove a file.

        :param path: File to remove. (string)
        :param recursive: Recursively remove directories. (bool)  Default: False
        :returns: A file like object that can be read.
        """
        endpoint = 'files/rm'
        args = [(path, 'string')]
        return self.client.get(endpoint, args, kwargs)

    async def files_stat(self, path, **kwargs):
        """
        Display file status.

        :param path: Path to node to stat. (string)
        :param format: Print statistics in given format. Allowed tokens: <hash> <size> <cumulsize> <type> <childs>. Conflicts with other format options. Default: <hash>
            Size: <size>
            CumulativeSize: <cumulsize>
            ChildBlocks: <childs>
            Type: <type>. (string)  Default: <hash>
            Size: <size>
            CumulativeSize: <cumulsize>
            ChildBlocks: <childs>
            Type: <type>
        :param hashname: Print only hash. Implies '--format=<hash>'. Conflicts with other format options. (bool)  Default: False
        :param size: Print only size. Implies '--format=<cumulsize>'. Conflicts with other format options. (bool)  Default: False
        :param with_local: Compute the amount of the dag that is local, and if possible the total size. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Hash": "<string>"
                    "Size": "<uint64>"
                    "CumulativeSize": "<uint64>"
                    "Blocks": "<int>"
                    "Type": "<string>"
                    "WithLocality": "<bool>"
                    "Local": "<bool>"
                    "SizeLocal": "<uint64>"
                }

        """
        endpoint = 'files/stat'
        args = [(path, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    def files_write(self, path, data, **kwargs):
        """
        Write to a mutable file in a given filesystem.

        :param path: Path to write to. (string)
        :param data: Data to write. (string)
        :param offset: Byte offset to begin writing at. (int)  Default: 0
        :param create: Create the file if it does not exist. (bool)  Default: False
        :param truncate: Truncate the file to size zero before writing. (bool)  Default: False
        :param count: Maximum number of bytes to read. (int)  Default: 0
        :param raw_leaves: Use raw blocks for newly created leaf nodes. (experimental). (bool)  Default: False
        :param cid_version: Cid version to use. (experimental). (int)  Default: 0
        :param hashname: Hash function to use. Will set Cid version to 1 if used. (experimental). (string)  Default: ""
        :returns: A file like object that can be read.
        """
        endpoint = 'files/write'
        args = [(path, 'string'), (data, 'file')]
        return self.client.get(endpoint, args, kwargs)

    async def filestore_dups(self, **kwargs):
        """
        List blocks that are both in the filestore and standard block storage.

        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Ref": "<string>"
                    "Err": "<string>"
                }

        """
        endpoint = 'filestore/dups'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def filestore_ls(self, **kwargs):
        """
        List objects in filestore.

        :param obj: Cid of objects to list. (string)  Default: ""
        :param file_order: sort the results based on the path of the backing file. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Status": "<int32>"
                    "ErrorMsg": "<string>"
                    "Key": "<string>"
                    "FilePath": "<string>"
                    "Offset": "<uint64>"
                    "Size": "<uint64>"
                }

        """
        endpoint = 'filestore/ls'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def filestore_verify(self, **kwargs):
        """
        Verify objects in filestore.

        :param obj: Cid of objects to verify. (string)  Default: ""
        :param file_order: verify the objects based on the order of the backing file. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Status": "<int32>"
                    "ErrorMsg": "<string>"
                    "Key": "<string>"
                    "FilePath": "<string>"
                    "Offset": "<uint64>"
                    "Size": "<uint64>"
                }

        """
        endpoint = 'filestore/verify'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    def get(self, ipfs_path, **kwargs):
        """
        Download IPFS objects.

        :param ipfs_path: The path to the IPFS object(s) to be outputted. (string)
        :param output: The path where the output should be stored. (string)  Default: ""
        :param archive: Output a TAR archive. (bool)  Default: False
        :param compress: Compress the output with GZIP compression. (bool)  Default: False
        :param compression_level: The level of compression (1-9). (int)  Default: 0
        :returns: A file like object that can be read.
        """
        endpoint = 'get'
        args = [(ipfs_path, 'string')]
        return self.client.get(endpoint, args, kwargs)

    async def id(self, **kwargs):
        """
        Show ipfs node id info.

        :param peerid: Peer.ID of node to look up. (string)  Default: ""
        :param format: Optional output format. (string)  Default: ""
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "ID": "<string>"
                    "PublicKey": "<string>"
                    "Addresses": [
                        "<string>"
                    ]
                    "AgentVersion": "<string>"
                    "ProtocolVersion": "<string>"
                }

        """
        endpoint = 'id'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def key_gen(self, name, **kwargs):
        """
        Create a new keypair

        :param name: name of key to create (string)
        :param type: type of the key to create [rsa, ed25519]. (string)  Default: ""
        :param size: size of the key to generate. (int)  Default: 0
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Name": "<string>"
                    "Id": "<string>"
                }

        """
        endpoint = 'key/gen'
        args = [(name, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def key_list(self, **kwargs):
        """
        List all local keypairs

        :param l: Show extra information about keys. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Keys": [
                        {
                            "Name": "<string>"
                            "Id": "<string>"
                        }
                    ]
                }

        """
        endpoint = 'key/list'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def key_rename(self, name, newname, **kwargs):
        """
        Rename a keypair

        :param name: name of key to rename (string)
        :param newname: new name of the key (string)
        :param force: Allow to overwrite an existing key. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Was": "<string>"
                    "Now": "<string>"
                    "Id": "<string>"
                    "Overwrite": "<bool>"
                }

        """
        endpoint = 'key/rename'
        args = [(name, 'string'), (newname, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def key_rm(self, name, **kwargs):
        """
        Remove a keypair

        :param name: names of keys to remove (string)
        :param l: Show extra information about keys. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Keys": [
                        {
                            "Name": "<string>"
                            "Id": "<string>"
                        }
                    ]
                }

        """
        endpoint = 'key/rm'
        args = [(name, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def log_level(self, subsystem, level, **kwargs):
        """
        Change the logging level.

        :param subsystem: The subsystem logging identifier. Use 'all' for all subsystems. (string)
        :param level: The log level, with 'debug' the most verbose and 'critical' the least verbose.
            			One of: debug, info, warning, error, critical.
            		 (string)
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Message": "<string>"
                }

        """
        endpoint = 'log/level'
        args = [(subsystem, 'string'), (level, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def log_ls(self, **kwargs):
        """
        List the logging subsystems.

        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Strings": [
                        "<string>"
                    ]
                }

        """
        endpoint = 'log/ls'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    def log_tail(self, **kwargs):
        """
        Read the event log.

        :returns: A file like object that can be read.
        """
        endpoint = 'log/tail'
        args = []
        return self.client.get(endpoint, args, kwargs)

    async def ls(self, ipfs_path, **kwargs):
        """
        List directory contents for Unix filesystem objects.

        :param ipfs_path: The path to the IPFS object(s) to list links from. (string)
        :param headers: Print table headers (Hash, Size, Name). (bool)  Default: False
        :param resolve_type: Resolve linked objects to find out their types. (bool)  Default: True
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Objects": [
                        {
                            "Hash": "<string>"
                            "Links": [
                                {
                                    "Name": "<string>"
                                    "Hash": "<string>"
                                    "Size": "<uint64>"
                                    "Type": "<int32>"
                                }
                            ]
                        }
                    ]
                }

        """
        endpoint = 'ls'
        args = [(ipfs_path, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def mount(self, **kwargs):
        """
        Mounts IPFS to the filesystem (read-only).

        :param ipfs_path: The path where IPFS should be mounted. (string)  Default: ""
        :param ipns_path: The path where IPNS should be mounted. (string)  Default: ""
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "IPFS": "<string>"
                    "IPNS": "<string>"
                    "FuseAllowOther": "<bool>"
                }

        """
        endpoint = 'mount'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def name_publish(self, ipfs_path, **kwargs):
        """
        Publish IPNS names.

        :param ipfs_path: ipfs path of the object to be published. (string)
        :param resolve: Resolve given path before publishing. (bool)  Default: True
        :param lifetime: Time duration that the record will be valid for.
                This accepts durations such as "300s", "1.5h" or "2h45m". Valid time units are
                "ns", "us" (or "µs"), "ms", "s", "m", "h". (string)  Default: 24h
        :param ttl: Time duration this record should be cached for (caution: experimental). (string)  Default: ""
        :param key: Name of the key to be used or a valid PeerID, as listed by 'ipfs key list -l'. Default:. (string)  Default: self
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Name": "<string>"
                    "Value": "<string>"
                }

        """
        endpoint = 'name/publish'
        args = [(ipfs_path, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def name_pubsub_cancel(self, name, **kwargs):
        """
        Cancel a name subscription

        :param name: Name to cancel the subscription for. (string)
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Canceled": "<bool>"
                }

        """
        endpoint = 'name/pubsub/cancel'
        args = [(name, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def name_pubsub_state(self, **kwargs):
        """
        Query the state of IPNS pubsub

        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Enabled": "<bool>"
                }

        """
        endpoint = 'name/pubsub/state'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def name_pubsub_subs(self, **kwargs):
        """
        Show current name subscriptions

        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Strings": [
                        "<string>"
                    ]
                }

        """
        endpoint = 'name/pubsub/subs'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def name_resolve(self, **kwargs):
        """
        Resolve IPNS names.

        :param name: The IPNS name to resolve. Defaults to your node's peerID. (string)  Default: ""
        :param recursive: Resolve until the result is not an IPNS name. (bool)  Default: False
        :param nocache: Do not use cached entries. (bool)  Default: False
        :param dht_record_count: Number of records to request for DHT resolution. (uint)  Default: 0
        :param dht_timeout: Max time to collect values during DHT resolution eg "30s". Pass 0 for no timeout. (string)  Default: ""
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Path": "<string>"
                }

        """
        endpoint = 'name/resolve'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    def object_data(self, key, **kwargs):
        """
        Output the raw bytes of an IPFS object.

        :param key: Key of the object to retrieve, in base58-encoded multihash format. (string)
        :returns: A file like object that can be read.
        """
        endpoint = 'object/data'
        args = [(key, 'string')]
        return self.client.get(endpoint, args, kwargs)

    async def object_diff(self, obj_a, obj_b, **kwargs):
        """
        Display the diff between two ipfs objects.

        :param obj_a: Object to diff against. (string)
        :param obj_b: Object to diff. (string)
        :param verbose: Print extra information. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Changes": [
                        {
                            "Type": "<int>"
                            "Path": "<string>"
                            "Before": "<string>"
                            "After": "<string>"
                        }
                    ]
                }

        """
        endpoint = 'object/diff'
        args = [(obj_a, 'string'), (obj_b, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def object_get(self, key, **kwargs):
        """
        Get and serialize the DAG node named by <key>.

        :param key: Key of the object to retrieve, in base58-encoded multihash format. (string)
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Links": [
                        {
                            "Name": "<string>"
                            "Hash": "<string>"
                            "Size": "<uint64>"
                        }
                    ]
                    "Data": "<string>"
                }

        """
        endpoint = 'object/get'
        args = [(key, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def object_links(self, key, **kwargs):
        """
        Output the links pointed to by the specified object.

        :param key: Key of the object to retrieve, in base58-encoded multihash format. (string)
        :param headers: Print table headers (Hash, Size, Name). (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Hash": "<string>"
                    "Links": [
                        {
                            "Name": "<string>"
                            "Hash": "<string>"
                            "Size": "<uint64>"
                        }
                    ]
                }

        """
        endpoint = 'object/links'
        args = [(key, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def object_new(self, **kwargs):
        """
        Create a new object from an ipfs template.

        :param template: Template to use. Optional. (string)  Default: ""
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Hash": "<string>"
                    "Links": [
                        {
                            "Name": "<string>"
                            "Hash": "<string>"
                            "Size": "<uint64>"
                        }
                    ]
                }

        """
        endpoint = 'object/new'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def object_patch_add_link(self, root, name, ref, **kwargs):
        """
        Add a link to a given object.

        :param root: The hash of the node to modify. (string)
        :param name: Name of link to create. (string)
        :param ref: IPFS object to add link to. (string)
        :param create: Create intermediary nodes. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Hash": "<string>"
                    "Links": [
                        {
                            "Name": "<string>"
                            "Hash": "<string>"
                            "Size": "<uint64>"
                        }
                    ]
                }

        """
        endpoint = 'object/patch/add-link'
        args = [(root, 'string'), (name, 'string'), (ref, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def object_patch_append_data(self, root, data, **kwargs):
        """
        Append data to the data segment of a dag node.

        :param root: The hash of the node to modify. (string)
        :param data: Data to append. (string)
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Hash": "<string>"
                    "Links": [
                        {
                            "Name": "<string>"
                            "Hash": "<string>"
                            "Size": "<uint64>"
                        }
                    ]
                }

        """
        endpoint = 'object/patch/append-data'
        args = [(root, 'string'), (data, 'file')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def object_patch_rm_link(self, root, link, **kwargs):
        """
        Remove a link from an object.

        :param root: The hash of the node to modify. (string)
        :param link: Name of the link to remove. (string)
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Hash": "<string>"
                    "Links": [
                        {
                            "Name": "<string>"
                            "Hash": "<string>"
                            "Size": "<uint64>"
                        }
                    ]
                }

        """
        endpoint = 'object/patch/rm-link'
        args = [(root, 'string'), (link, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def object_patch_set_data(self, root, data, **kwargs):
        """
        Set the data field of an IPFS object.

        :param root: The hash of the node to modify. (string)
        :param data: The data to set the object to. (string)
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Hash": "<string>"
                    "Links": [
                        {
                            "Name": "<string>"
                            "Hash": "<string>"
                            "Size": "<uint64>"
                        }
                    ]
                }

        """
        endpoint = 'object/patch/set-data'
        args = [(root, 'string'), (data, 'file')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def object_put(self, data, **kwargs):
        """
        Store input as a DAG object, print its key.

        :param data: Data to be stored as a DAG object. (string)
        :param inputenc: Encoding type of input data. One of: {"protobuf", "json"}. (string)  Default: json
        :param datafieldenc: Encoding type of the data field, either "text" or "base64". (string)  Default: text
        :param pin: Pin this object when adding. (bool)  Default: False
        :param quiet: Write minimal output. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Hash": "<string>"
                    "Links": [
                        {
                            "Name": "<string>"
                            "Hash": "<string>"
                            "Size": "<uint64>"
                        }
                    ]
                }

        """
        endpoint = 'object/put'
        args = [(data, 'file')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def object_stat(self, key, **kwargs):
        """
        Get stats for the DAG node named by <key>.

        :param key: Key of the object to retrieve, in base58-encoded multihash format. (string)
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Hash": "<string>"
                    "NumLinks": "<int>"
                    "BlockSize": "<int>"
                    "LinksSize": "<int>"
                    "DataSize": "<int>"
                    "CumulativeSize": "<int>"
                }

        """
        endpoint = 'object/stat'
        args = [(key, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    def p2p_listener_close(self, **kwargs):
        """
        Close active p2p listener.

        :param protocol: P2P listener protocol (string)  Default: ""
        :param all: Close all listeners. (bool)  Default: False
        :returns: A file like object that can be read.
        """
        endpoint = 'p2p/listener/close'
        args = []
        return self.client.get(endpoint, args, kwargs)

    async def p2p_listener_ls(self, **kwargs):
        """
        List active p2p listeners.

        :param headers: Print table headers (HandlerID, Protocol, Local, Remote). (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Listeners": [
                        {
                            "Protocol": "<string>"
                            "Address": "<string>"
                        }
                    ]
                }

        """
        endpoint = 'p2p/listener/ls'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    def p2p_listener_open(self, protocol, address, **kwargs):
        """
        Forward p2p connections to a network multiaddr.

        :param protocol: Protocol identifier. (string)
        :param address: Request handling application address. (string)
        :returns: A file like object that can be read.
        """
        endpoint = 'p2p/listener/open'
        args = [(protocol, 'string'), (address, 'string')]
        return self.client.get(endpoint, args, kwargs)

    def p2p_stream_close(self, **kwargs):
        """
        Close active p2p stream.

        :param handlerid: Stream HandlerID (string)  Default: ""
        :param all: Close all streams. (bool)  Default: False
        :returns: A file like object that can be read.
        """
        endpoint = 'p2p/stream/close'
        args = []
        return self.client.get(endpoint, args, kwargs)

    def p2p_stream_dial(self, peer, protocol, **kwargs):
        """
        Dial to a p2p listener.

        :param peer: Remote peer to connect to (string)
        :param protocol: Protocol identifier. (string)
        :param bindaddress: Address to listen for connection/s (default: /ip4/127.0.0.1/tcp/0). (string)  Default: ""
        :returns: A file like object that can be read.
        """
        endpoint = 'p2p/stream/dial'
        args = [(peer, 'string'), (protocol, 'string')]
        return self.client.get(endpoint, args, kwargs)

    async def p2p_stream_ls(self, **kwargs):
        """
        List active p2p streams.

        :param headers: Print table headers (HagndlerID, Protocol, Local, Remote). (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Streams": [
                        {
                            "HandlerID": "<string>"
                            "Protocol": "<string>"
                            "LocalPeer": "<string>"
                            "LocalAddress": "<string>"
                            "RemotePeer": "<string>"
                            "RemoteAddress": "<string>"
                        }
                    ]
                }

        """
        endpoint = 'p2p/stream/ls'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def pin_add(self, ipfs_path, **kwargs):
        """
        Pin objects to local storage.

        :param ipfs_path: Path to object(s) to be pinned. (string)
        :param recursive: Recursively pin the object linked to by the specified object(s). (bool)  Default: True
        :param progress: Show progress. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Pins": [
                        "<string>"
                    ]
                    "Progress": "<int>"
                }

        """
        endpoint = 'pin/add'
        args = [(ipfs_path, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def pin_ls(self, **kwargs):
        """
        List objects pinned to local storage.

        :param ipfs_path: Path to object(s) to be listed. (string)  Default: ""
        :param type: The type of pinned keys to list. Can be "direct", "indirect", "recursive", or "all". (string)  Default: all
        :param quiet: Write just hashes of objects. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Keys": {
                        "<string>": {
                            "Type": "<string>"
                        }
                    }
                }

        """
        endpoint = 'pin/ls'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def pin_rm(self, ipfs_path, **kwargs):
        """
        Remove pinned objects from local storage.

        :param ipfs_path: Path to object(s) to be unpinned. (string)
        :param recursive: Recursively unpin the object linked to by the specified object(s). (bool)  Default: True
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Pins": [
                        "<string>"
                    ]
                }

        """
        endpoint = 'pin/rm'
        args = [(ipfs_path, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def pin_update(self, from_path, to_path, **kwargs):
        """
        Update a recursive pin

        :param from_path: Path to old object. (string)
        :param to_path: Path to new object to be pinned. (string)
        :param unpin: Remove the old pin. (bool)  Default: True
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Pins": [
                        "<string>"
                    ]
                }

        """
        endpoint = 'pin/update'
        args = [(from_path, 'string'), (to_path, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def pin_verify(self, **kwargs):
        """
        Verify that recursive pins are complete.

        :param verbose: Also write the hashes of non-broken pins. (bool)  Default: False
        :param quiet: Write just hashes of broken pins. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Cid": "<string>"
                    "PinStatus": {
                        "Ok": "<bool>"
                        "BadNodes": [
                            {
                                "Cid": "<string>"
                                "Err": "<string>"
                            }
                        ]
                    }
                }

        """
        endpoint = 'pin/verify'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def ping(self, peer_id, **kwargs):
        """
        Send echo request packets to IPFS hosts.

        :param peer_id: ID of peer to be pinged. (string)
        :param count: Number of ping messages to send. (int)  Default: 10
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Success": "<bool>"
                    "Time": "<int64>"
                    "Text": "<string>"
                }

        """
        endpoint = 'ping'
        args = [(peer_id, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def pubsub_ls(self, **kwargs):
        """
        List subscribed topics by name.

        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Strings": [
                        "<string>"
                    ]
                }

        """
        endpoint = 'pubsub/ls'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def pubsub_peers(self, **kwargs):
        """
        List peers we are currently pubsubbing with.

        :param topic: topic to list connected peers of (string)  Default: ""
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Strings": [
                        "<string>"
                    ]
                }

        """
        endpoint = 'pubsub/peers'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    def pubsub_pub(self, topic, data, **kwargs):
        """
        Publish a message to a given pubsub topic.

        :param topic: Topic to publish to. (string)
        :param data: Payload of message to publish. (string)
        :returns: A file like object that can be read.
        """
        endpoint = 'pubsub/pub'
        args = [(topic, 'string'), (data, 'string')]
        return self.client.get(endpoint, args, kwargs)

    async def pubsub_sub(self, topic, **kwargs):
        """
        Subscribe to messages on a given topic.

        :param topic: String name of topic to subscribe to. (string)
        :param discover: try to discover other peers subscribed to the same topic. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Message": {
                        "From": [
                            "<uint8>"
                        ]
                        "Data": [
                            "<uint8>"
                        ]
                        "Seqno": [
                            "<uint8>"
                        ]
                        "TopicIDs": [
                            "<string>"
                        ]
                        "XXX_unrecognized": [
                            "<uint8>"
                        ]
                    }
                }

        """
        endpoint = 'pubsub/sub'
        args = [(topic, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def refs_local(self, **kwargs):
        """
        List all local references.

        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Ref": "<string>"
                    "Err": "<string>"
                }

        """
        endpoint = 'refs/local'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def repo_fsck(self, **kwargs):
        """
        Remove repo lockfiles.

        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Message": "<string>"
                }

        """
        endpoint = 'repo/fsck'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def repo_gc(self, **kwargs):
        """
        Perform a garbage collection sweep on the repo.

        :param stream_errors: Stream errors. (bool)  Default: False
        :param quiet: Write minimal output. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Key": "<string>"
                    "Error": "<string>"
                }

        """
        endpoint = 'repo/gc'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def repo_stat(self, **kwargs):
        """
        Get stats for the currently used repo.

        :param human: Output RepoSize in MiB. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "NumObjects": "<uint64>"
                    "RepoSize": "<uint64>"
                    "RepoPath": "<string>"
                    "Version": "<string>"
                    "StorageMax": "<uint64>"
                }

        """
        endpoint = 'repo/stat'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def repo_verify(self, **kwargs):
        """
        Verify all blocks in repo are not corrupted.

        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Msg": "<string>"
                    "Progress": "<int>"
                }

        """
        endpoint = 'repo/verify'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def repo_version(self, **kwargs):
        """
        Show the repo version.

        :param quiet: Write minimal output. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Version": "<string>"
                }

        """
        endpoint = 'repo/version'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def resolve(self, name, **kwargs):
        """
        Resolve the value of names to IPFS.

        :param name: The name to resolve. (string)
        :param recursive: Resolve until the result is an IPFS name. (bool)  Default: False
        :param dht_record_count: Number of records to request for DHT resolution. (uint)  Default: 0
        :param dht_timeout: Max time to collect values during DHT resolution eg "30s". Pass 0 for no timeout. (string)  Default: ""
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Path": "<string>"
                }

        """
        endpoint = 'resolve'
        args = [(name, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    def shutdown(self, **kwargs):
        """
        Shut down the ipfs daemon

        :returns: A file like object that can be read.
        """
        endpoint = 'shutdown'
        args = []
        return self.client.get(endpoint, args, kwargs)

    async def stats_bitswap(self, **kwargs):
        """
        Show some diagnostic information on the bitswap agent.

        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "ProvideBufLen": "<int>"
                    "Wantlist": [
                        "<string>"
                    ]
                    "Peers": [
                        "<string>"
                    ]
                    "BlocksReceived": "<uint64>"
                    "DataReceived": "<uint64>"
                    "BlocksSent": "<uint64>"
                    "DataSent": "<uint64>"
                    "DupBlksReceived": "<uint64>"
                    "DupDataReceived": "<uint64>"
                }

        """
        endpoint = 'stats/bitswap'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def stats_bw(self, **kwargs):
        """
        Print ipfs bandwidth information.

        :param peer: Specify a peer to print bandwidth for. (string)  Default: ""
        :param proto: Specify a protocol to print bandwidth for. (string)  Default: ""
        :param poll: Print bandwidth at an interval. (bool)  Default: False
        :param interval: Time interval to wait between updating output, if 'poll' is true.
                This accepts durations such as "300s", "1.5h" or "2h45m". Valid time units are:
                "ns", "us" (or "µs"), "ms", "s", "m", "h". (string)  Default: 1s
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "TotalIn": "<int64>"
                    "TotalOut": "<int64>"
                    "RateIn": "<float64>"
                    "RateOut": "<float64>"
                }

        """
        endpoint = 'stats/bw'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def stats_repo(self, **kwargs):
        """
        Get stats for the currently used repo.

        :param human: Output RepoSize in MiB. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "NumObjects": "<uint64>"
                    "RepoSize": "<uint64>"
                    "RepoPath": "<string>"
                    "Version": "<string>"
                    "StorageMax": "<uint64>"
                }

        """
        endpoint = 'stats/repo'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def swarm_addrs_listen(self, **kwargs):
        """
        List interface listening addresses.

        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Strings": [
                        "<string>"
                    ]
                }

        """
        endpoint = 'swarm/addrs/listen'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def swarm_addrs_local(self, **kwargs):
        """
        List local addresses.

        :param id: Show peer ID in addresses. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Strings": [
                        "<string>"
                    ]
                }

        """
        endpoint = 'swarm/addrs/local'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def swarm_connect(self, address, **kwargs):
        """
        Open connection to a given address.

        :param address: Address of peer to connect to. (string)
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Strings": [
                        "<string>"
                    ]
                }

        """
        endpoint = 'swarm/connect'
        args = [(address, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def swarm_disconnect(self, address, **kwargs):
        """
        Close connection to a given address.

        :param address: Address of peer to disconnect from. (string)
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Strings": [
                        "<string>"
                    ]
                }

        """
        endpoint = 'swarm/disconnect'
        args = [(address, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def swarm_filters_add(self, address, **kwargs):
        """
        Add an address filter.

        :param address: Multiaddr to filter. (string)
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Strings": [
                        "<string>"
                    ]
                }

        """
        endpoint = 'swarm/filters/add'
        args = [(address, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def swarm_filters_rm(self, address, **kwargs):
        """
        Remove an address filter.

        :param address: Multiaddr filter to remove. (string)
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Strings": [
                        "<string>"
                    ]
                }

        """
        endpoint = 'swarm/filters/rm'
        args = [(address, 'string')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def swarm_peers(self, **kwargs):
        """
        List peers with open connections.

        :param verbose: display all extra information. (bool)  Default: False
        :param streams: Also list information about open streams for each peer. (bool)  Default: False
        :param latency: Also list information about latency to each peer. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Peers": [
                        {
                            "Addr": "<string>"
                            "Peer": "<string>"
                            "Latency": "<string>"
                            "Muxer": "<string>"
                            "Streams": [
                                {
                                    "Protocol": "<string>"
                                }
                            ]
                        }
                    ]
                }

        """
        endpoint = 'swarm/peers'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)

    async def tar_add(self, file, **kwargs):
        """
        Import a tar file into ipfs.

        :param file: Tar file to add. (string)
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Name": "<string>"
                    "Hash": "<string>"
                    "Bytes": "<int64>"
                    "Size": "<string>"
                }

        """
        endpoint = 'tar/add'
        args = [(file, 'file')]
        return await self.client.get_parsed(endpoint, args, kwargs)

    def tar_cat(self, path, **kwargs):
        """
        Export a tar file from IPFS.

        :param path: ipfs path of archive to export. (string)
        :returns: A file like object that can be read.
        """
        endpoint = 'tar/cat'
        args = [(path, 'string')]
        return self.client.get(endpoint, args, kwargs)

    def update(self, **kwargs):
        """
        :param args: Arguments for subcommand. (string)  Default: ""
        :returns: A file like object that can be read.
        """
        endpoint = 'update'
        args = []
        return self.client.get(endpoint, args, kwargs)

    async def version(self, **kwargs):
        """
        Show ipfs version information.

        :param number: Only show the version number. (bool)  Default: False
        :param commit: Show the commit hash. (bool)  Default: False
        :param repo: Show repo version. (bool)  Default: False
        :param all: Show all version information. (bool)  Default: False
        :returns: A parsed dict result of:

            .. code-block:: python

                {
                    "Version": "<string>"
                    "Commit": "<string>"
                    "Repo": "<string>"
                    "System": "<string>"
                    "Golang": "<string>"
                }

        """
        endpoint = 'version'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)
