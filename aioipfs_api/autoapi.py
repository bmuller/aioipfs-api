# IPFS Interface, autogenerated, don't touch!

class IPFSInterface:
	
    async def add(self, path, **kwargs):
        """
        Add a file or directory to ipfs.

        :param path: The path to a file to be added to ipfs. (file).
        :param recursive: Add directory paths recursively. Default: false. (bool).  Default: false
        :param quiet: Write minimal output. (bool).  Default: 
        :param quieter: Write only final hash. (bool).  Default: 
        :param silent: Write no output. (bool).  Default: 
        :param progress: Stream progress data. (bool).  Default: 
        :param trickle: Use trickle-dag format for dag generation. (bool).  Default: 
        :param only_hash: Only chunk and hash - do not write to disk. (bool).  Default: 
        :param wrap_with_directory: Wrap files with a directory object. (bool).  Default: 
        :param hidden: Include files that are hidden. Only takes effect on recursive add. (bool).  Default: 
        :param chunker: Chunking algorithm, size-[bytes] or rabin-[min]-[avg]-[max]. Default: size-262144. (string).  Default: size-262144
        :param pin: Pin this object when adding. Default: true. (bool).  Default: true
        :param raw_leaves: Use raw blocks for leaf nodes. (experimental). (bool).  Default: 
        :param nocopy: Add the file using filestore. Implies raw-leaves. (experimental). (bool).  Default: 
        :param fscache: Check the filestore for pre-existing blocks. (experimental). (bool).  Default: 
        :param cid_version: CID version. Defaults to 0 unless an option that depends on CIDv1 is passed. (experimental). (int).  Default: 
        :param hash: Hash function to use. Implies CIDv1 if not sha2-256. (experimental). Default: sha2-256. (string).  Default: sha2-256
        :returns: A parsed result of {
            "Name": "<string>"
            "Hash": "<string>"
            "Bytes": "<int64>"
            "Size": "<string>"
        }
        """
        endpoint = 'add'
        args = [path]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def bitswap_ledger(self, peer, **kwargs):
        """
        Show the current ledger for a peer.

        :param peer: The PeerID (B58) of the ledger to inspect. (string).
        :returns: A parsed result of {
            "Peer": "<string>"
            "Value": "<float64>"
            "Sent": "<uint64>"
            "Recv": "<uint64>"
            "Exchanged": "<uint64>"
        }
        """
        endpoint = 'bitswap/ledger'
        args = [peer]
        return await self.client.get_parsed(endpoint, args, kwargs)


    def bitswap_reprovide(self, **kwargs):
        """
        Trigger reprovider.

        :returns: A readable file like object
        """
        endpoint = 'bitswap/reprovide'
        args = []
        return self.client.get(endpoint, args, kwargs)


    async def bitswap_stat(self, **kwargs):
        """
        Show some diagnostic information on the bitswap agent.

        :returns: A parsed result of {
            "ProvideBufLen": "<int>"
            "Wantlist": [
                "<string>"
            ]
            "Peers": [
                "<string>"
            ]
            "BlocksReceived": "<uint64>"
            "DataReceived": "<uint64>"
            "BlocksSent": "<uint64>"
            "DataSent": "<uint64>"
            "DupBlksReceived": "<uint64>"
            "DupDataReceived": "<uint64>"
        }
        """
        endpoint = 'bitswap/stat'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    def bitswap_unwant(self, key, **kwargs):
        """
        Remove a given block from your wantlist.

        :param key: Key(s) to remove from your wantlist. (string).
        :returns: A readable file like object
        """
        endpoint = 'bitswap/unwant'
        args = [key]
        return self.client.get(endpoint, args, kwargs)


    async def bitswap_wantlist(self, **kwargs):
        """
        Show blocks currently on the wantlist.

        :param peer: Specify which peer to show wantlist for. Default: self. (string).  Default: 
        :returns: A parsed result of {
            "Keys": [
                "<string>"
            ]
        }
        """
        endpoint = 'bitswap/wantlist'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    def block_get(self, key, **kwargs):
        """
        Get a raw IPFS block.

        :param key: The base58 multihash of an existing block to get. (string).
        :returns: A readable file like object
        """
        endpoint = 'block/get'
        args = [key]
        return self.client.get(endpoint, args, kwargs)


    async def block_put(self, data, **kwargs):
        """
        Store input as an IPFS block.

        :param data: The data to be stored as an IPFS block. (file).
        :param format: cid format for blocks to be created with. (string).  Default: 
        :param mhtype: multihash hash function. Default: sha2-256. (string).  Default: sha2-256
        :param mhlen: multihash hash length. Default: -1. (int).  Default: -1
        :returns: A parsed result of {
            "Key": "<string>"
            "Size": "<int>"
        }
        """
        endpoint = 'block/put'
        args = [data]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def block_rm(self, hash, **kwargs):
        """
        Remove IPFS block(s).

        :param hash: Bash58 encoded multihash of block(s) to remove. (string).
        :param force: Ignore nonexistent blocks. (bool).  Default: 
        :param quiet: Write minimal output. (bool).  Default: 
        :returns: A parsed result of {
            "Hash": "<string>"
            "Error": "<string>"
        }
        """
        endpoint = 'block/rm'
        args = [hash]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def block_stat(self, key, **kwargs):
        """
        Print information of a raw IPFS block.

        :param key: The base58 multihash of an existing block to stat. (string).
        :returns: A parsed result of {
            "Key": "<string>"
            "Size": "<int>"
        }
        """
        endpoint = 'block/stat'
        args = [key]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def bootstrap_add_default(self, **kwargs):
        """
        Add default peers to the bootstrap list.

        :returns: A parsed result of {
            "Peers": [
                "<string>"
            ]
        }
        """
        endpoint = 'bootstrap/add/default'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def bootstrap_list(self, **kwargs):
        """
        Show peers in the bootstrap list.

        :returns: A parsed result of {
            "Peers": [
                "<string>"
            ]
        }
        """
        endpoint = 'bootstrap/list'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def bootstrap_rm_all(self, **kwargs):
        """
        Remove all peers from the bootstrap list.

        :returns: A parsed result of {
            "Peers": [
                "<string>"
            ]
        }
        """
        endpoint = 'bootstrap/rm/all'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    def cat(self, ipfs_path, **kwargs):
        """
        Show IPFS object data.

        :param ipfs_path: The path to the IPFS object(s) to be outputted. (string).
        :param offset: Byte offset to begin reading from. (int).  Default: 
        :param length: Maximum number of bytes to read. (int).  Default: 
        :returns: A readable file like object
        """
        endpoint = 'cat'
        args = [ipfs_path]
        return self.client.get(endpoint, args, kwargs)


    async def commands(self, **kwargs):
        """
        List all available commands.

        :param flags: Show command flags. (bool).  Default: 
        :returns: A parsed result of {
            "Name": "<string>"
            "Subcommands": [
                {
                    "Name": "<string>"
                    "Subcommands": [
                        {
                            "Name": "<string>"
                            "Subcommands": [
                                ...
                            ]
                            "Options": [
                                ...
                            ]
                            "showOpts": "<bool>"
                        }
                    ]
                    "Options": [
                        {
                            "Names": [
                                ...
                            ]
                        }
                    ]
                    "showOpts": "<bool>"
                }
            ]
            "Options": [
                {
                    "Names": [
                        "<string>"
                    ]
                }
            ]
            "showOpts": "<bool>"
        }
        """
        endpoint = 'commands'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    def config_edit(self, **kwargs):
        """
        Open the config file for editing in $EDITOR.

        :returns: A readable file like object
        """
        endpoint = 'config/edit'
        args = []
        return self.client.get(endpoint, args, kwargs)


    def config_profile_apply(self, profile, **kwargs):
        """
        Apply profile to config.

        :param profile: The profile to apply to the config. (string).
        :returns: A readable file like object
        """
        endpoint = 'config/profile/apply'
        args = [profile]
        return self.client.get(endpoint, args, kwargs)


    def config_replace(self, file, **kwargs):
        """
        Replace the config with <file>.

        :param file: The file to use as the new config. (file).
        :returns: A readable file like object
        """
        endpoint = 'config/replace'
        args = [file]
        return self.client.get(endpoint, args, kwargs)


    def config_show(self, **kwargs):
        """
        Output config file contents.

        :returns: A readable file like object
        """
        endpoint = 'config/show'
        args = []
        return self.client.get(endpoint, args, kwargs)


    def dag_get(self, ref, **kwargs):
        """
        Get a dag node from ipfs.

        :param ref: The object to get (string).
        :returns: A readable file like object
        """
        endpoint = 'dag/get'
        args = [ref]
        return self.client.get(endpoint, args, kwargs)


    async def dag_put(self, object_data, **kwargs):
        """
        Add a dag node to ipfs.

        :param object_data: The object to put (file).
        :param format: Format that the object will be added as. Default: cbor. (string).  Default: cbor
        :param input_enc: Format that the input object will be. Default: json. (string).  Default: json
        :param pin: Pin this object when adding. (bool).  Default: 
        :param hash: Hash function to use. Default: . (string).  Default: 
        :returns: A parsed result of {
            "Cid": "<string>"
        }
        """
        endpoint = 'dag/put'
        args = [object_data]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def dag_resolve(self, ref, **kwargs):
        """
        Resolve ipld block

        :param ref: The path to resolve (string).
        :returns: A parsed result of {
            "Cid": "<string>"
            "RemPath": "<string>"
        }
        """
        endpoint = 'dag/resolve'
        args = [ref]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def dht_findpeer(self, peerID, **kwargs):
        """
        Query the DHT for all of the multiaddresses associated with a Peer ID.

        :param peerID: The ID of the peer to search for. (string).
        :param verbose: Print extra information. (bool).  Default: 
        :returns: A parsed result of {
            "ID": "<string>"
            "Type": "<int>"
            "Responses": [
                {
                    "ID": "<string>"
                    "Addrs": [
                        "<object>"
                    ]
                }
            ]
            "Extra": "<string>"
        }
        """
        endpoint = 'dht/findpeer'
        args = [peerID]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def dht_findprovs(self, key, **kwargs):
        """
        Find peers in the DHT that can provide a specific value, given a key.

        :param key: The key to find providers for. (string).
        :param verbose: Print extra information. (bool).  Default: 
        :param num_providers: The number of providers to find. Default: 20. (int).  Default: 20
        :returns: A parsed result of {
            "ID": "<string>"
            "Type": "<int>"
            "Responses": [
                {
                    "ID": "<string>"
                    "Addrs": [
                        "<object>"
                    ]
                }
            ]
            "Extra": "<string>"
        }
        """
        endpoint = 'dht/findprovs'
        args = [key]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def dht_get(self, key, **kwargs):
        """
        Given a key, query the DHT for its best value.

        :param key: The key to find a value for. (string).
        :param verbose: Print extra information. (bool).  Default: 
        :returns: A parsed result of {
            "ID": "<string>"
            "Type": "<int>"
            "Responses": [
                {
                    "ID": "<string>"
                    "Addrs": [
                        "<object>"
                    ]
                }
            ]
            "Extra": "<string>"
        }
        """
        endpoint = 'dht/get'
        args = [key]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def dht_provide(self, key, **kwargs):
        """
        Announce to the network that you are providing given values.

        :param key: The key[s] to send provide records for. (string).
        :param verbose: Print extra information. (bool).  Default: 
        :param recursive: Recursively provide entire graph. (bool).  Default: 
        :returns: A parsed result of {
            "ID": "<string>"
            "Type": "<int>"
            "Responses": [
                {
                    "ID": "<string>"
                    "Addrs": [
                        "<object>"
                    ]
                }
            ]
            "Extra": "<string>"
        }
        """
        endpoint = 'dht/provide'
        args = [key]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def dht_put(self, key, value, **kwargs):
        """
        Write a key/value pair to the DHT.

        :param key: The key to store the value at. (string).
        :param value: The value to store. (string).
        :param verbose: Print extra information. (bool).  Default: 
        :returns: A parsed result of {
            "ID": "<string>"
            "Type": "<int>"
            "Responses": [
                {
                    "ID": "<string>"
                    "Addrs": [
                        "<object>"
                    ]
                }
            ]
            "Extra": "<string>"
        }
        """
        endpoint = 'dht/put'
        args = [key, value]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def dht_query(self, peerID, **kwargs):
        """
        Find the closest Peer IDs to a given Peer ID by querying the DHT.

        :param peerID: The peerID to run the query against. (string).
        :param verbose: Print extra information. (bool).  Default: 
        :returns: A parsed result of {
            "ID": "<string>"
            "Type": "<int>"
            "Responses": [
                {
                    "ID": "<string>"
                    "Addrs": [
                        "<object>"
                    ]
                }
            ]
            "Extra": "<string>"
        }
        """
        endpoint = 'dht/query'
        args = [peerID]
        return await self.client.get_parsed(endpoint, args, kwargs)


    def diag_cmds_clear(self, **kwargs):
        """
        Clear inactive requests from the log.

        :returns: A readable file like object
        """
        endpoint = 'diag/cmds/clear'
        args = []
        return self.client.get(endpoint, args, kwargs)


    def diag_cmds_set_time(self, time, **kwargs):
        """
        Set how long to keep inactive requests in the log.

        :param time: Time to keep inactive requests in log. (string).
        :returns: A readable file like object
        """
        endpoint = 'diag/cmds/set-time'
        args = [time]
        return self.client.get(endpoint, args, kwargs)


    def diag_sys(self, **kwargs):
        """
        Print system diagnostic information.

        :returns: A readable file like object
        """
        endpoint = 'diag/sys'
        args = []
        return self.client.get(endpoint, args, kwargs)


    async def dns(self, domain_name, **kwargs):
        """
        Resolve DNS links.

        :param domain_name: The domain-name name to resolve. (string).
        :param recursive: Resolve until the result is not a DNS link. (bool).  Default: 
        :returns: A parsed result of {
            "Path": "<string>"
        }
        """
        endpoint = 'dns'
        args = [domain_name]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def file_ls(self, ipfs_path, **kwargs):
        """
        List directory contents for Unix filesystem objects.

        :param ipfs_path: The path to the IPFS object(s) to list links from. (string).
        :returns: A parsed result of {
            "Arguments": {
                "<string>": "<string>"
            }
            "Objects": {
                "<string>": {
                    "Hash": "<string>"
                    "Size": "<uint64>"
                    "Type": "<string>"
                    "Links": [
                        {
                            "Name": "<string>"
                            "Hash": "<string>"
                            "Size": "<uint64>"
                            "Type": "<string>"
                        }
                    ]
                }
            }
        }
        """
        endpoint = 'file/ls'
        args = [ipfs_path]
        return await self.client.get_parsed(endpoint, args, kwargs)


    def files_chcid(self, **kwargs):
        """
        Change the cid version or hash function of the root node of a given path.

        :param path: Path to change. Default: '/'. (string).  Default: 
        :param cid_version: Cid version to use. (experimental). (int).  Default: 
        :param hash: Hash function to use. Will set Cid version to 1 if used. (experimental). (string).  Default: 
        :returns: A readable file like object
        """
        endpoint = 'files/chcid'
        args = []
        return self.client.get(endpoint, args, kwargs)


    def files_cp(self, source, dest, **kwargs):
        """
        Copy files into mfs.

        :param source: Source object to copy. (string).
        :param dest: Destination to copy object to. (string).
        :returns: A readable file like object
        """
        endpoint = 'files/cp'
        args = [source, dest]
        return self.client.get(endpoint, args, kwargs)


    def files_flush(self, **kwargs):
        """
        Flush a given path's data to disk.

        :param path: Path to flush. Default: '/'. (string).  Default: 
        :returns: A readable file like object
        """
        endpoint = 'files/flush'
        args = []
        return self.client.get(endpoint, args, kwargs)


    async def files_ls(self, **kwargs):
        """
        List directories in the local mutable namespace.

        :param path: Path to show listing for. Defaults to '/'. (string).  Default: 
        :param l: Use long listing format. (bool).  Default: 
        :returns: A parsed result of {
            "Entries": [
                {
                    "Name": "<string>"
                    "Type": "<int>"
                    "Size": "<int64>"
                    "Hash": "<string>"
                }
            ]
        }
        """
        endpoint = 'files/ls'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    def files_mkdir(self, path, **kwargs):
        """
        Make directories.

        :param path: Path to dir to make. (string).
        :param parents: No error if existing, make parent directories as needed. (bool).  Default: 
        :param cid_version: Cid version to use. (experimental). (int).  Default: 
        :param hash: Hash function to use. Will set Cid version to 1 if used. (experimental). (string).  Default: 
        :returns: A readable file like object
        """
        endpoint = 'files/mkdir'
        args = [path]
        return self.client.get(endpoint, args, kwargs)


    def files_mv(self, source, dest, **kwargs):
        """
        Move files.

        :param source: Source file to move. (string).
        :param dest: Destination path for file to be moved to. (string).
        :returns: A readable file like object
        """
        endpoint = 'files/mv'
        args = [source, dest]
        return self.client.get(endpoint, args, kwargs)


    def files_read(self, path, **kwargs):
        """
        Read a file in a given mfs.

        :param path: Path to file to be read. (string).
        :param offset: Byte offset to begin reading from. (int).  Default: 
        :param count: Maximum number of bytes to read. (int).  Default: 
        :returns: A readable file like object
        """
        endpoint = 'files/read'
        args = [path]
        return self.client.get(endpoint, args, kwargs)


    def files_rm(self, path, **kwargs):
        """
        Remove a file.

        :param path: File to remove. (string).
        :param recursive: Recursively remove directories. (bool).  Default: 
        :returns: A readable file like object
        """
        endpoint = 'files/rm'
        args = [path]
        return self.client.get(endpoint, args, kwargs)


    async def files_stat(self, path, **kwargs):
        """
        Display file status.

        :param path: Path to node to stat. (string).
        :param format: Print statistics in given format. Allowed tokens: <hash> <size> <cumulsize> <type> <childs>. Conflicts with other format options. Default: <hash>
        Size: <size>
        CumulativeSize: <cumulsize>
        ChildBlocks: <childs>
        Type: <type>. (string).  Default: <hash>
        Size: <size>
        CumulativeSize: <cumulsize>
        ChildBlocks: <childs>
        Type: <type>
        :param hash: Print only hash. Implies '--format=<hash>'. Conflicts with other format options. (bool).  Default: 
        :param size: Print only size. Implies '--format=<cumulsize>'. Conflicts with other format options. (bool).  Default: 
        :param with_local: Compute the amount of the dag that is local, and if possible the total size. (bool).  Default: 
        :returns: A parsed result of {
            "Hash": "<string>"
            "Size": "<uint64>"
            "CumulativeSize": "<uint64>"
            "Blocks": "<int>"
            "Type": "<string>"
            "WithLocality": "<bool>"
            "Local": "<bool>"
            "SizeLocal": "<uint64>"
        }
        """
        endpoint = 'files/stat'
        args = [path]
        return await self.client.get_parsed(endpoint, args, kwargs)


    def files_write(self, path, data, **kwargs):
        """
        Write to a mutable file in a given filesystem.

        :param path: Path to write to. (string).
        :param data: Data to write. (file).
        :param offset: Byte offset to begin writing at. (int).  Default: 
        :param create: Create the file if it does not exist. (bool).  Default: 
        :param truncate: Truncate the file to size zero before writing. (bool).  Default: 
        :param count: Maximum number of bytes to read. (int).  Default: 
        :param raw_leaves: Use raw blocks for newly created leaf nodes. (experimental). (bool).  Default: 
        :param cid_version: Cid version to use. (experimental). (int).  Default: 
        :param hash: Hash function to use. Will set Cid version to 1 if used. (experimental). (string).  Default: 
        :returns: A readable file like object
        """
        endpoint = 'files/write'
        args = [path, data]
        return self.client.get(endpoint, args, kwargs)


    async def filestore_dups(self, **kwargs):
        """
        List blocks that are both in the filestore and standard block storage.

        :returns: A parsed result of {
            "Ref": "<string>"
            "Err": "<string>"
        }
        """
        endpoint = 'filestore/dups'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def filestore_ls(self, **kwargs):
        """
        List objects in filestore.

        :param obj: Cid of objects to list. (string).  Default: 
        :param file_order: sort the results based on the path of the backing file. (bool).  Default: 
        :returns: A parsed result of {
            "Status": "<int32>"
            "ErrorMsg": "<string>"
            "Key": "<string>"
            "FilePath": "<string>"
            "Offset": "<uint64>"
            "Size": "<uint64>"
        }
        """
        endpoint = 'filestore/ls'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def filestore_verify(self, **kwargs):
        """
        Verify objects in filestore.

        :param obj: Cid of objects to verify. (string).  Default: 
        :param file_order: verify the objects based on the order of the backing file. (bool).  Default: 
        :returns: A parsed result of {
            "Status": "<int32>"
            "ErrorMsg": "<string>"
            "Key": "<string>"
            "FilePath": "<string>"
            "Offset": "<uint64>"
            "Size": "<uint64>"
        }
        """
        endpoint = 'filestore/verify'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    def get(self, ipfs_path, **kwargs):
        """
        Download IPFS objects.

        :param ipfs_path: The path to the IPFS object(s) to be outputted. (string).
        :param output: The path where the output should be stored. (string).  Default: 
        :param archive: Output a TAR archive. (bool).  Default: 
        :param compress: Compress the output with GZIP compression. (bool).  Default: 
        :param compression_level: The level of compression (1-9). (int).  Default: 
        :returns: A readable file like object
        """
        endpoint = 'get'
        args = [ipfs_path]
        return self.client.get(endpoint, args, kwargs)


    async def id(self, **kwargs):
        """
        Show ipfs node id info.

        :param peerid: Peer.ID of node to look up. (string).  Default: 
        :param format: Optional output format. (string).  Default: 
        :returns: A parsed result of {
            "ID": "<string>"
            "PublicKey": "<string>"
            "Addresses": [
                "<string>"
            ]
            "AgentVersion": "<string>"
            "ProtocolVersion": "<string>"
        }
        """
        endpoint = 'id'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def key_gen(self, name, **kwargs):
        """
        Create a new keypair

        :param name: name of key to create (string).
        :param type: type of the key to create [rsa, ed25519]. (string).  Default: 
        :param size: size of the key to generate. (int).  Default: 
        :returns: A parsed result of {
            "Name": "<string>"
            "Id": "<string>"
        }
        """
        endpoint = 'key/gen'
        args = [name]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def key_list(self, **kwargs):
        """
        List all local keypairs

        :param l: Show extra information about keys. (bool).  Default: 
        :returns: A parsed result of {
            "Keys": [
                {
                    "Name": "<string>"
                    "Id": "<string>"
                }
            ]
        }
        """
        endpoint = 'key/list'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def key_rename(self, name, newName, **kwargs):
        """
        Rename a keypair

        :param name: name of key to rename (string).
        :param newName: new name of the key (string).
        :param force: Allow to overwrite an existing key. (bool).  Default: 
        :returns: A parsed result of {
            "Was": "<string>"
            "Now": "<string>"
            "Id": "<string>"
            "Overwrite": "<bool>"
        }
        """
        endpoint = 'key/rename'
        args = [name, newName]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def key_rm(self, name, **kwargs):
        """
        Remove a keypair

        :param name: names of keys to remove (string).
        :param l: Show extra information about keys. (bool).  Default: 
        :returns: A parsed result of {
            "Keys": [
                {
                    "Name": "<string>"
                    "Id": "<string>"
                }
            ]
        }
        """
        endpoint = 'key/rm'
        args = [name]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def log_level(self, subsystem, level, **kwargs):
        """
        Change the logging level.

        :param subsystem: The subsystem logging identifier. Use 'all' for all subsystems. (string).
        :param level: The log level, with 'debug' the most verbose and 'critical' the least verbose.
        			One of: debug, info, warning, error, critical.
        		 (string).
        :returns: A parsed result of {
            "Message": "<string>"
        }
        """
        endpoint = 'log/level'
        args = [subsystem, level]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def log_ls(self, **kwargs):
        """
        List the logging subsystems.

        :returns: A parsed result of {
            "Strings": [
                "<string>"
            ]
        }
        """
        endpoint = 'log/ls'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    def log_tail(self, **kwargs):
        """
        Read the event log.

        :returns: A readable file like object
        """
        endpoint = 'log/tail'
        args = []
        return self.client.get(endpoint, args, kwargs)


    async def ls(self, ipfs_path, **kwargs):
        """
        List directory contents for Unix filesystem objects.

        :param ipfs_path: The path to the IPFS object(s) to list links from. (string).
        :param headers: Print table headers (Hash, Size, Name). (bool).  Default: 
        :param resolve_type: Resolve linked objects to find out their types. Default: true. (bool).  Default: true
        :returns: A parsed result of {
            "Objects": [
                {
                    "Hash": "<string>"
                    "Links": [
                        {
                            "Name": "<string>"
                            "Hash": "<string>"
                            "Size": "<uint64>"
                            "Type": "<int32>"
                        }
                    ]
                }
            ]
        }
        """
        endpoint = 'ls'
        args = [ipfs_path]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def mount(self, **kwargs):
        """
        Mounts IPFS to the filesystem (read-only).

        :param ipfs_path: The path where IPFS should be mounted. (string).  Default: 
        :param ipns_path: The path where IPNS should be mounted. (string).  Default: 
        :returns: A parsed result of {
            "IPFS": "<string>"
            "IPNS": "<string>"
            "FuseAllowOther": "<bool>"
        }
        """
        endpoint = 'mount'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def name_publish(self, ipfs_path, **kwargs):
        """
        Publish IPNS names.

        :param ipfs_path: ipfs path of the object to be published. (string).
        :param resolve: Resolve given path before publishing. Default: true. (bool).  Default: true
        :param lifetime: Time duration that the record will be valid for. Default: 24h.
            This accepts durations such as "300s", "1.5h" or "2h45m". Valid time units are
            "ns", "us" (or "µs"), "ms", "s", "m", "h". (string).  Default: 24h
        :param ttl: Time duration this record should be cached for (caution: experimental). (string).  Default: 
        :param key: Name of the key to be used or a valid PeerID, as listed by 'ipfs key list -l'. Default: Default: self.. (string).  Default: self
        :returns: A parsed result of {
            "Name": "<string>"
            "Value": "<string>"
        }
        """
        endpoint = 'name/publish'
        args = [ipfs_path]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def name_pubsub_cancel(self, name, **kwargs):
        """
        Cancel a name subscription

        :param name: Name to cancel the subscription for. (string).
        :returns: A parsed result of {
            "Canceled": "<bool>"
        }
        """
        endpoint = 'name/pubsub/cancel'
        args = [name]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def name_pubsub_state(self, **kwargs):
        """
        Query the state of IPNS pubsub

        :returns: A parsed result of {
            "Enabled": "<bool>"
        }
        """
        endpoint = 'name/pubsub/state'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def name_pubsub_subs(self, **kwargs):
        """
        Show current name subscriptions

        :returns: A parsed result of {
            "Strings": [
                "<string>"
            ]
        }
        """
        endpoint = 'name/pubsub/subs'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def name_resolve(self, **kwargs):
        """
        Resolve IPNS names.

        :param name: The IPNS name to resolve. Defaults to your node's peerID. (string).  Default: 
        :param recursive: Resolve until the result is not an IPNS name. (bool).  Default: 
        :param nocache: Do not use cached entries. (bool).  Default: 
        :param dht_record_count: Number of records to request for DHT resolution. (uint).  Default: 
        :param dht_timeout: Max time to collect values during DHT resolution eg "30s". Pass 0 for no timeout. (string).  Default: 
        :returns: A parsed result of {
            "Path": "<string>"
        }
        """
        endpoint = 'name/resolve'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    def object_data(self, key, **kwargs):
        """
        Output the raw bytes of an IPFS object.

        :param key: Key of the object to retrieve, in base58-encoded multihash format. (string).
        :returns: A readable file like object
        """
        endpoint = 'object/data'
        args = [key]
        return self.client.get(endpoint, args, kwargs)


    async def object_diff(self, obj_a, obj_b, **kwargs):
        """
        Display the diff between two ipfs objects.

        :param obj_a: Object to diff against. (string).
        :param obj_b: Object to diff. (string).
        :param verbose: Print extra information. (bool).  Default: 
        :returns: A parsed result of {
            "Changes": [
                {
                    "Type": "<int>"
                    "Path": "<string>"
                    "Before": "<string>"
                    "After": "<string>"
                }
            ]
        }
        """
        endpoint = 'object/diff'
        args = [obj_a, obj_b]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def object_get(self, key, **kwargs):
        """
        Get and serialize the DAG node named by <key>.

        :param key: Key of the object to retrieve, in base58-encoded multihash format. (string).
        :returns: A parsed result of {
            "Links": [
                {
                    "Name": "<string>"
                    "Hash": "<string>"
                    "Size": "<uint64>"
                }
            ]
            "Data": "<string>"
        }
        """
        endpoint = 'object/get'
        args = [key]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def object_links(self, key, **kwargs):
        """
        Output the links pointed to by the specified object.

        :param key: Key of the object to retrieve, in base58-encoded multihash format. (string).
        :param headers: Print table headers (Hash, Size, Name). (bool).  Default: 
        :returns: A parsed result of {
            "Hash": "<string>"
            "Links": [
                {
                    "Name": "<string>"
                    "Hash": "<string>"
                    "Size": "<uint64>"
                }
            ]
        }
        """
        endpoint = 'object/links'
        args = [key]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def object_new(self, **kwargs):
        """
        Create a new object from an ipfs template.

        :param template: Template to use. Optional. (string).  Default: 
        :returns: A parsed result of {
            "Hash": "<string>"
            "Links": [
                {
                    "Name": "<string>"
                    "Hash": "<string>"
                    "Size": "<uint64>"
                }
            ]
        }
        """
        endpoint = 'object/new'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def object_patch_add_link(self, root, name, ref, **kwargs):
        """
        Add a link to a given object.

        :param root: The hash of the node to modify. (string).
        :param name: Name of link to create. (string).
        :param ref: IPFS object to add link to. (string).
        :param create: Create intermediary nodes. (bool).  Default: 
        :returns: A parsed result of {
            "Hash": "<string>"
            "Links": [
                {
                    "Name": "<string>"
                    "Hash": "<string>"
                    "Size": "<uint64>"
                }
            ]
        }
        """
        endpoint = 'object/patch/add-link'
        args = [root, name, ref]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def object_patch_append_data(self, root, data, **kwargs):
        """
        Append data to the data segment of a dag node.

        :param root: The hash of the node to modify. (string).
        :param data: Data to append. (file).
        :returns: A parsed result of {
            "Hash": "<string>"
            "Links": [
                {
                    "Name": "<string>"
                    "Hash": "<string>"
                    "Size": "<uint64>"
                }
            ]
        }
        """
        endpoint = 'object/patch/append-data'
        args = [root, data]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def object_patch_rm_link(self, root, link, **kwargs):
        """
        Remove a link from an object.

        :param root: The hash of the node to modify. (string).
        :param link: Name of the link to remove. (string).
        :returns: A parsed result of {
            "Hash": "<string>"
            "Links": [
                {
                    "Name": "<string>"
                    "Hash": "<string>"
                    "Size": "<uint64>"
                }
            ]
        }
        """
        endpoint = 'object/patch/rm-link'
        args = [root, link]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def object_patch_set_data(self, root, data, **kwargs):
        """
        Set the data field of an IPFS object.

        :param root: The hash of the node to modify. (string).
        :param data: The data to set the object to. (file).
        :returns: A parsed result of {
            "Hash": "<string>"
            "Links": [
                {
                    "Name": "<string>"
                    "Hash": "<string>"
                    "Size": "<uint64>"
                }
            ]
        }
        """
        endpoint = 'object/patch/set-data'
        args = [root, data]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def object_put(self, data, **kwargs):
        """
        Store input as a DAG object, print its key.

        :param data: Data to be stored as a DAG object. (file).
        :param inputenc: Encoding type of input data. One of: {"protobuf", "json"}. Default: json. (string).  Default: json
        :param datafieldenc: Encoding type of the data field, either "text" or "base64". Default: text. (string).  Default: text
        :param pin: Pin this object when adding. (bool).  Default: 
        :param quiet: Write minimal output. (bool).  Default: 
        :returns: A parsed result of {
            "Hash": "<string>"
            "Links": [
                {
                    "Name": "<string>"
                    "Hash": "<string>"
                    "Size": "<uint64>"
                }
            ]
        }
        """
        endpoint = 'object/put'
        args = [data]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def object_stat(self, key, **kwargs):
        """
        Get stats for the DAG node named by <key>.

        :param key: Key of the object to retrieve, in base58-encoded multihash format. (string).
        :returns: A parsed result of {
            "Hash": "<string>"
            "NumLinks": "<int>"
            "BlockSize": "<int>"
            "LinksSize": "<int>"
            "DataSize": "<int>"
            "CumulativeSize": "<int>"
        }
        """
        endpoint = 'object/stat'
        args = [key]
        return await self.client.get_parsed(endpoint, args, kwargs)


    def p2p_listener_close(self, **kwargs):
        """
        Close active p2p listener.

        :param Protocol: P2P listener protocol (string).  Default: 
        :param all: Close all listeners. (bool).  Default: 
        :returns: A readable file like object
        """
        endpoint = 'p2p/listener/close'
        args = []
        return self.client.get(endpoint, args, kwargs)


    async def p2p_listener_ls(self, **kwargs):
        """
        List active p2p listeners.

        :param headers: Print table headers (HandlerID, Protocol, Local, Remote). (bool).  Default: 
        :returns: A parsed result of {
            "Listeners": [
                {
                    "Protocol": "<string>"
                    "Address": "<string>"
                }
            ]
        }
        """
        endpoint = 'p2p/listener/ls'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    def p2p_listener_open(self, Protocol, Address, **kwargs):
        """
        Forward p2p connections to a network multiaddr.

        :param Protocol: Protocol identifier. (string).
        :param Address: Request handling application address. (string).
        :returns: A readable file like object
        """
        endpoint = 'p2p/listener/open'
        args = [Protocol, Address]
        return self.client.get(endpoint, args, kwargs)


    def p2p_stream_close(self, **kwargs):
        """
        Close active p2p stream.

        :param HandlerID: Stream HandlerID (string).  Default: 
        :param all: Close all streams. (bool).  Default: 
        :returns: A readable file like object
        """
        endpoint = 'p2p/stream/close'
        args = []
        return self.client.get(endpoint, args, kwargs)


    def p2p_stream_dial(self, Peer, Protocol, **kwargs):
        """
        Dial to a p2p listener.

        :param Peer: Remote peer to connect to (string).
        :param Protocol: Protocol identifier. (string).
        :param BindAddress: Address to listen for connection/s (default: /ip4/127.0.0.1/tcp/0). (string).  Default: 
        :returns: A readable file like object
        """
        endpoint = 'p2p/stream/dial'
        args = [Peer, Protocol]
        return self.client.get(endpoint, args, kwargs)


    async def p2p_stream_ls(self, **kwargs):
        """
        List active p2p streams.

        :param headers: Print table headers (HagndlerID, Protocol, Local, Remote). (bool).  Default: 
        :returns: A parsed result of {
            "Streams": [
                {
                    "HandlerID": "<string>"
                    "Protocol": "<string>"
                    "LocalPeer": "<string>"
                    "LocalAddress": "<string>"
                    "RemotePeer": "<string>"
                    "RemoteAddress": "<string>"
                }
            ]
        }
        """
        endpoint = 'p2p/stream/ls'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def pin_add(self, ipfs_path, **kwargs):
        """
        Pin objects to local storage.

        :param ipfs_path: Path to object(s) to be pinned. (string).
        :param recursive: Recursively pin the object linked to by the specified object(s). Default: true. (bool).  Default: true
        :param progress: Show progress. (bool).  Default: 
        :returns: A parsed result of {
            "Pins": [
                "<string>"
            ]
            "Progress": "<int>"
        }
        """
        endpoint = 'pin/add'
        args = [ipfs_path]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def pin_ls(self, **kwargs):
        """
        List objects pinned to local storage.

        :param ipfs_path: Path to object(s) to be listed. (string).  Default: 
        :param type: The type of pinned keys to list. Can be "direct", "indirect", "recursive", or "all". Default: all. (string).  Default: all
        :param quiet: Write just hashes of objects. (bool).  Default: 
        :returns: A parsed result of {
            "Keys": {
                "<string>": {
                    "Type": "<string>"
                }
            }
        }
        """
        endpoint = 'pin/ls'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def pin_rm(self, ipfs_path, **kwargs):
        """
        Remove pinned objects from local storage.

        :param ipfs_path: Path to object(s) to be unpinned. (string).
        :param recursive: Recursively unpin the object linked to by the specified object(s). Default: true. (bool).  Default: true
        :returns: A parsed result of {
            "Pins": [
                "<string>"
            ]
        }
        """
        endpoint = 'pin/rm'
        args = [ipfs_path]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def pin_update(self, from_path, to_path, **kwargs):
        """
        Update a recursive pin

        :param from_path: Path to old object. (string).
        :param to_path: Path to new object to be pinned. (string).
        :param unpin: Remove the old pin. Default: true. (bool).  Default: true
        :returns: A parsed result of {
            "Pins": [
                "<string>"
            ]
        }
        """
        endpoint = 'pin/update'
        args = [from_path, to_path]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def pin_verify(self, **kwargs):
        """
        Verify that recursive pins are complete.

        :param verbose: Also write the hashes of non-broken pins. (bool).  Default: 
        :param quiet: Write just hashes of broken pins. (bool).  Default: 
        :returns: A parsed result of {
            "Cid": "<string>"
            "PinStatus": {
                "Ok": "<bool>"
                "BadNodes": [
                    {
                        "Cid": "<string>"
                        "Err": "<string>"
                    }
                ]
            }
        }
        """
        endpoint = 'pin/verify'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def ping(self, peer_ID, **kwargs):
        """
        Send echo request packets to IPFS hosts.

        :param peer_ID: ID of peer to be pinged. (string).
        :param count: Number of ping messages to send. Default: 10. (int).  Default: 10
        :returns: A parsed result of {
            "Success": "<bool>"
            "Time": "<int64>"
            "Text": "<string>"
        }
        """
        endpoint = 'ping'
        args = [peer_ID]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def pubsub_ls(self, **kwargs):
        """
        List subscribed topics by name.

        :returns: A parsed result of {
            "Strings": [
                "<string>"
            ]
        }
        """
        endpoint = 'pubsub/ls'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def pubsub_peers(self, **kwargs):
        """
        List peers we are currently pubsubbing with.

        :param topic: topic to list connected peers of (string).  Default: 
        :returns: A parsed result of {
            "Strings": [
                "<string>"
            ]
        }
        """
        endpoint = 'pubsub/peers'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    def pubsub_pub(self, topic, data, **kwargs):
        """
        Publish a message to a given pubsub topic.

        :param topic: Topic to publish to. (string).
        :param data: Payload of message to publish. (string).
        :returns: A readable file like object
        """
        endpoint = 'pubsub/pub'
        args = [topic, data]
        return self.client.get(endpoint, args, kwargs)


    async def pubsub_sub(self, topic, **kwargs):
        """
        Subscribe to messages on a given topic.

        :param topic: String name of topic to subscribe to. (string).
        :param discover: try to discover other peers subscribed to the same topic. (bool).  Default: 
        :returns: A parsed result of {
            "Message": {
                "From": [
                    "<uint8>"
                ]
                "Data": [
                    "<uint8>"
                ]
                "Seqno": [
                    "<uint8>"
                ]
                "TopicIDs": [
                    "<string>"
                ]
                "XXX_unrecognized": [
                    "<uint8>"
                ]
            }
        }
        """
        endpoint = 'pubsub/sub'
        args = [topic]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def refs_local(self, **kwargs):
        """
        List all local references.

        :returns: A parsed result of {
            "Ref": "<string>"
            "Err": "<string>"
        }
        """
        endpoint = 'refs/local'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def repo_fsck(self, **kwargs):
        """
        Remove repo lockfiles.

        :returns: A parsed result of {
            "Message": "<string>"
        }
        """
        endpoint = 'repo/fsck'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def repo_gc(self, **kwargs):
        """
        Perform a garbage collection sweep on the repo.

        :param stream_errors: Stream errors. (bool).  Default: 
        :param quiet: Write minimal output. (bool).  Default: 
        :returns: A parsed result of {
            "Key": "<string>"
            "Error": "<string>"
        }
        """
        endpoint = 'repo/gc'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def repo_stat(self, **kwargs):
        """
        Get stats for the currently used repo.

        :param human: Output RepoSize in MiB. (bool).  Default: 
        :returns: A parsed result of {
            "NumObjects": "<uint64>"
            "RepoSize": "<uint64>"
            "RepoPath": "<string>"
            "Version": "<string>"
            "StorageMax": "<uint64>"
        }
        """
        endpoint = 'repo/stat'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def repo_verify(self, **kwargs):
        """
        Verify all blocks in repo are not corrupted.

        :returns: A parsed result of {
            "Msg": "<string>"
            "Progress": "<int>"
        }
        """
        endpoint = 'repo/verify'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def repo_version(self, **kwargs):
        """
        Show the repo version.

        :param quiet: Write minimal output. (bool).  Default: 
        :returns: A parsed result of {
            "Version": "<string>"
        }
        """
        endpoint = 'repo/version'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def resolve(self, name, **kwargs):
        """
        Resolve the value of names to IPFS.

        :param name: The name to resolve. (string).
        :param recursive: Resolve until the result is an IPFS name. (bool).  Default: 
        :param dht_record_count: Number of records to request for DHT resolution. (uint).  Default: 
        :param dht_timeout: Max time to collect values during DHT resolution eg "30s". Pass 0 for no timeout. (string).  Default: 
        :returns: A parsed result of {
            "Path": "<string>"
        }
        """
        endpoint = 'resolve'
        args = [name]
        return await self.client.get_parsed(endpoint, args, kwargs)


    def shutdown(self, **kwargs):
        """
        Shut down the ipfs daemon

        :returns: A readable file like object
        """
        endpoint = 'shutdown'
        args = []
        return self.client.get(endpoint, args, kwargs)


    async def stats_bitswap(self, **kwargs):
        """
        Show some diagnostic information on the bitswap agent.

        :returns: A parsed result of {
            "ProvideBufLen": "<int>"
            "Wantlist": [
                "<string>"
            ]
            "Peers": [
                "<string>"
            ]
            "BlocksReceived": "<uint64>"
            "DataReceived": "<uint64>"
            "BlocksSent": "<uint64>"
            "DataSent": "<uint64>"
            "DupBlksReceived": "<uint64>"
            "DupDataReceived": "<uint64>"
        }
        """
        endpoint = 'stats/bitswap'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def stats_bw(self, **kwargs):
        """
        Print ipfs bandwidth information.

        :param peer: Specify a peer to print bandwidth for. (string).  Default: 
        :param proto: Specify a protocol to print bandwidth for. (string).  Default: 
        :param poll: Print bandwidth at an interval. (bool).  Default: 
        :param interval: Time interval to wait between updating output, if 'poll' is true.
        
            This accepts durations such as "300s", "1.5h" or "2h45m". Valid time units are:
            "ns", "us" (or "µs"), "ms", "s", "m", "h". Default: 1s. (string).  Default: 1s
        :returns: A parsed result of {
            "TotalIn": "<int64>"
            "TotalOut": "<int64>"
            "RateIn": "<float64>"
            "RateOut": "<float64>"
        }
        """
        endpoint = 'stats/bw'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def stats_repo(self, **kwargs):
        """
        Get stats for the currently used repo.

        :param human: Output RepoSize in MiB. (bool).  Default: 
        :returns: A parsed result of {
            "NumObjects": "<uint64>"
            "RepoSize": "<uint64>"
            "RepoPath": "<string>"
            "Version": "<string>"
            "StorageMax": "<uint64>"
        }
        """
        endpoint = 'stats/repo'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def swarm_addrs_listen(self, **kwargs):
        """
        List interface listening addresses.

        :returns: A parsed result of {
            "Strings": [
                "<string>"
            ]
        }
        """
        endpoint = 'swarm/addrs/listen'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def swarm_addrs_local(self, **kwargs):
        """
        List local addresses.

        :param id: Show peer ID in addresses. (bool).  Default: 
        :returns: A parsed result of {
            "Strings": [
                "<string>"
            ]
        }
        """
        endpoint = 'swarm/addrs/local'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def swarm_connect(self, address, **kwargs):
        """
        Open connection to a given address.

        :param address: Address of peer to connect to. (string).
        :returns: A parsed result of {
            "Strings": [
                "<string>"
            ]
        }
        """
        endpoint = 'swarm/connect'
        args = [address]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def swarm_disconnect(self, address, **kwargs):
        """
        Close connection to a given address.

        :param address: Address of peer to disconnect from. (string).
        :returns: A parsed result of {
            "Strings": [
                "<string>"
            ]
        }
        """
        endpoint = 'swarm/disconnect'
        args = [address]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def swarm_filters_add(self, address, **kwargs):
        """
        Add an address filter.

        :param address: Multiaddr to filter. (string).
        :returns: A parsed result of {
            "Strings": [
                "<string>"
            ]
        }
        """
        endpoint = 'swarm/filters/add'
        args = [address]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def swarm_filters_rm(self, address, **kwargs):
        """
        Remove an address filter.

        :param address: Multiaddr filter to remove. (string).
        :returns: A parsed result of {
            "Strings": [
                "<string>"
            ]
        }
        """
        endpoint = 'swarm/filters/rm'
        args = [address]
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def swarm_peers(self, **kwargs):
        """
        List peers with open connections.

        :param verbose: display all extra information. (bool).  Default: 
        :param streams: Also list information about open streams for each peer. (bool).  Default: 
        :param latency: Also list information about latency to each peer. (bool).  Default: 
        :returns: A parsed result of {
            "Peers": [
                {
                    "Addr": "<string>"
                    "Peer": "<string>"
                    "Latency": "<string>"
                    "Muxer": "<string>"
                    "Streams": [
                        {
                            "Protocol": "<string>"
                        }
                    ]
                }
            ]
        }
        """
        endpoint = 'swarm/peers'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)


    async def tar_add(self, file, **kwargs):
        """
        Import a tar file into ipfs.

        :param file: Tar file to add. (file).
        :returns: A parsed result of {
            "Name": "<string>"
            "Hash": "<string>"
            "Bytes": "<int64>"
            "Size": "<string>"
        }
        """
        endpoint = 'tar/add'
        args = [file]
        return await self.client.get_parsed(endpoint, args, kwargs)


    def tar_cat(self, path, **kwargs):
        """
        Export a tar file from IPFS.

        :param path: ipfs path of archive to export. (string).
        :returns: A readable file like object
        """
        endpoint = 'tar/cat'
        args = [path]
        return self.client.get(endpoint, args, kwargs)


    def update(self, **kwargs):
        """
        

        :param args: Arguments for subcommand. (string).  Default: 
        :returns: A readable file like object
        """
        endpoint = 'update'
        args = []
        return self.client.get(endpoint, args, kwargs)


    async def version(self, **kwargs):
        """
        Show ipfs version information.

        :param number: Only show the version number. (bool).  Default: 
        :param commit: Show the commit hash. (bool).  Default: 
        :param repo: Show repo version. (bool).  Default: 
        :param all: Show all version information. (bool).  Default: 
        :returns: A parsed result of {
            "Version": "<string>"
            "Commit": "<string>"
            "Repo": "<string>"
            "System": "<string>"
            "Golang": "<string>"
        }
        """
        endpoint = 'version'
        args = []
        return await self.client.get_parsed(endpoint, args, kwargs)



